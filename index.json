[{"categories":null,"content":"ADB ","date":"2023-09-25","objectID":"/adb/:0:0","tags":null,"title":"Adb","uri":"/adb/"},{"categories":null,"content":"USE ADB in WSL # ADB export PATH=\"$PATH:/mnt/d/Tools/Android/SDK/platform-tools\" alias adb=\"/mnt/d/Tools/Android/SDK/platform-tools/adb.exe\" 由于将adb的路径alias后，默认在sh中是找不到的，若想在sh脚本中使用ADB，需在脚本前添加以下代码: #!/bin/bash -i shopt -s expand_aliases ","date":"2023-09-25","objectID":"/adb/:1:0","tags":null,"title":"Adb","uri":"/adb/"},{"categories":null,"content":"Usage adb push ready_to_push path adb pull path_to_want # if read-only system adb remout ","date":"2023-09-25","objectID":"/adb/:2:0","tags":null,"title":"Adb","uri":"/adb/"},{"categories":null,"content":"Misc ","date":"2023-09-25","objectID":"/misc/:0:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"exp from pwn import * import sys context.log_level = \"debug\" if len(sys.argv) \u003c 2: debug = True else: debug = False if debug: p = process(\"./\") libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") else: p = remote(\"\",) libc = ELF(\"./libc-2.31.so\") ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\"b *$rebase({b})\".format(b = hex(b))) else: gdb.attach(p) #context.terminal = ['tmux', 'splitw', '-h'] p.interactive() ","date":"2023-09-25","objectID":"/misc/:1:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"查找错误git commit git bisect ","date":"2023-09-25","objectID":"/misc/:2:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"Debug Multithreading # gdb set follow-fork-mode [parent|child] # 设置调试[父进程/子进程] set detach-on-fork [on|off] # 未调试进程[继续执行/block在fork位置] show follow-fork-mode show detach-on-fork info inferiors # 查看正在调试的进程信息 info threads # 查询线程 thread \u003cthread number\u003e # 切换线程 strace -ff -o test.txt ./your_binary ","date":"2023-09-25","objectID":"/misc/:3:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"hex dump void hexdump(const void *data, size_t size) { char ascii[17]; size_t i, j; ascii[16] = '\\0'; for (i = 0; i \u003c size; ++i) { dprintf(2, \"%02X \", ((unsigned char *)data)[i]); if (((unsigned char *)data)[i] \u003e= ' ' \u0026\u0026 ((unsigned char *)data)[i] \u003c= '~') { ascii[i % 16] = ((unsigned char *)data)[i]; } else { ascii[i % 16] = '.'; } if ((i + 1) % 8 == 0 || i + 1 == size) { dprintf(2, \" \"); if ((i + 1) % 16 == 0) { dprintf(2, \"| %s \\n\", ascii); } else if (i + 1 == size) { ascii[(i + 1) % 16] = '\\0'; if ((i + 1) % 16 \u003c= 8) { dprintf(2, \" \"); } for (j = (i + 1) % 16; j \u003c 16; ++j) { dprintf(2, \" \"); } dprintf(2, \"| %s \\n\", ascii); } } } } ","date":"2023-09-25","objectID":"/misc/:4:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"ropper ropper --file ./vmlinux --nocolor \u003e gadgets.txt ","date":"2023-09-25","objectID":"/misc/:5:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"pow #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cmemory.h\u003e #include \u003cstdint.h\u003e #include \u003copenssl/sha.h\u003e #define PREFIX_LEN 10 int main(int argc, char const *argv[]) { if (argc != 2 || strlen(argv[1]) != PREFIX_LEN) return -1; uint8_t buf[32]; uint8_t out[SHA256_DIGEST_LENGTH]; memcpy(buf, argv[1], PREFIX_LEN); for (uint64_t i = 0; i \u003c 0xffffffffffff; ++i) { sprintf(buf + PREFIX_LEN, \"%lu\", i); SHA256(buf, strlen(buf), out); if (out[0] == 0 \u0026\u0026 out[1] == 0 \u0026\u0026 out[2] == 0 \u0026\u0026 (out[3] \u003e\u003e 5) == 0) { printf(\"%s\\n\", buf+10); break; } } return 0; } // gcc -O2 pow.c -lcrypto \u0026\u0026 ./a.out pzlYZX5ZEb \u0026\u0026 rm ./a.out pow from Crypto.Util.number import getPrime,bytes_to_long from pwn import * from parse import * from pwnlib.util.iters import bruteforce from hashlib import sha256 def brute_force(prefix,s): return bruteforce(lambda x:sha256((prefix+x).encode()).hexdigest()==s,string.ascii_letters+string.digits,length=4,method='fixed') p=remote('52.163.228.53', 8081) data = p.recvline()[:-1] prefix, s = parse(\"sha256(xxxx+{}) == {}\",data.decode()) p.sendline(brute_force(prefix,s)) p.interactive() ","date":"2023-09-25","objectID":"/misc/:6:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"docker docker rm -f `docker ps -a -q` ","date":"2023-09-25","objectID":"/misc/:7:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"自定义传参规则 void __usercall xxxxx(char* a1@\u003crdi\u003e) ","date":"2023-09-25","objectID":"/misc/:7:1","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"修改ida字符串显示 # puts(aStr) ---\u003e puts(\"str\") change str seg -\u003e r_x ","date":"2023-09-25","objectID":"/misc/:7:2","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"musl-gcc for kernel # we cannot compile the exploit using musl-gcc, which produces small binary. The problem is that it seems that musl-gcc cannot find the \u003clinux/xxx.h\u003e header files. I solved this by preprocessing exploit using gcc -E and compiling the preprocessing output using musl-gcc gcc -E exp.c -o fs/exp.c musl-gcc -static fs/exp.c -o fs/exp ","date":"2023-09-25","objectID":"/misc/:8:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"remote exp upload from pwn import * import base64 context.log_level = \"debug\" with open(\"./exp\", \"rb\") as f: exp = base64.b64encode(f.read()) def do_pow(r): cmd = r.recvline()[:-1] rr = os.popen(cmd.decode()) r.sendline(rr.read()) p = remote('babypf.seccon.games',9009) do_pow(p) try_count = 1 while True: log.info(\"no.\" + str(try_count) + \" time(s)\") p.sendline() p.recvuntil(\"/ $\") count = 0 for i in range(0, len(exp), 0x200): p.sendline(\"echo -n \\\"\" + exp[i:i + 0x200].decode() + \"\\\" \u003e\u003e /tmp/b64_exp\") count += 1 for i in range(count): p.recvuntil(\"/ $\") p.sendline(\"cat /tmp/b64_exp | base64 -d \u003e /tmp/exploit\") p.sendline(\"chmod +x /tmp/exploit\") randomization = (try_count % 1024) * 0x100000 log.info('trying randomization: ' + hex(randomization)) if not p.recvuntil(b\"Rebooting in 1 seconds..\", timeout=20): break log.warn('failed!') try_count += 1 log.success('success to get the root shell!') p.interactive() ","date":"2023-09-25","objectID":"/misc/:9:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"debug # debug.sh gdb qemu-system-x86_64 --pid `ps -ef | grep qemu | awk '{print $2}' | head -n 1` -x ./debug.source # debug.source b *addr c ","date":"2023-09-25","objectID":"/misc/:10:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"tmux set-option -g mouse on # 开启鼠标支持 setw -g mode-keys vi # 支持vi模式 set-option -s set-clipboard on # 开启系统剪切板支持 ## 鼠标滚轮模拟 # Emulate scrolling by sending up and down keys if these commands are running in the pane tmux_commands_with_legacy_scroll=\"nano less more man\" bind-key -T root WheelUpPane \\ if-shell -Ft= '#{?mouse_any_flag,1,#{pane_in_mode}}' \\ 'send -Mt=' \\ 'if-shell -t= \"#{?alternate_on,true,false} || echo \\\"#{tmux_commands_with_legacy_scroll}\\\" | grep -q \\\"#{pane_current_command}\\\"\" \\ \"send -t= Up Up Up\" \"copy-mode -et=\"' bind-key -T root WheelDownPane \\ if-shell -Ft = '#{?pane_in_mode,1,#{mouse_any_flag}}' \\ 'send -Mt=' \\ 'if-shell -t= \"#{?alternate_on,true,false} || echo \\\"#{tmux_commands_with_legacy_scroll}\\\" | grep -q \\\"#{pane_current_command}\\\"\" \\ \"send -t= Down Down Down\" \"send -Mt=\"' ","date":"2023-09-25","objectID":"/misc/:11:0","tags":null,"title":"Misc","uri":"/misc/"},{"categories":null,"content":"patchelf patchelf --set-interpreter ld_path xxx patchelf --set-rpath libc_dir xxx ","date":"2023-09-25","objectID":"/misc/:12:0","tags":null,"title":"Misc","uri":"/misc/"}]