[{"categories":["tee"],"content":"ta //------------------------------------------------ //--- 010 Editor v10.0.2 Binary Template // // File: // Authors: // Version: // Purpose: // Category: // File Mask: // ID Bytes: // History: //------------------------------------------------ #define TEE_FS_HTREE_IV_SIZE 16 #define TEE_FS_HTREE_TAG_SIZE 16 #define TEE_FS_HTREE_FEK_SIZE 16 typedef struct _tee_fs_htree_meta { UINT64 length; }tee_fs_htree_meta; typedef struct _tee_fs_htree_imeta { struct tee_fs_htree_meta meta; UINT32 max_node_id; UINT32 nop; }tee_fs_htree_imeta; typedef struct _tee_fs_htree_image { UCHAR iv[TEE_FS_HTREE_IV_SIZE]; UCHAR tag[TEE_FS_HTREE_TAG_SIZE]; UCHAR enc_fek[TEE_FS_HTREE_FEK_SIZE]; UCHAR imeta[sizeof(struct tee_fs_htree_imeta)]; UINT32 counter; }tee_fs_htree_image; #define TEE_FS_HTREE_HASH_SIZE 32 #define TEE_FS_HTREE_IV_SIZE 16 #define TEE_FS_HTREE_TAG_SIZE 16 typedef struct _tee_fs_htree_node_image { /* Note that calc_node_hash() depends on hash first in struct */ UCHAR hash[TEE_FS_HTREE_HASH_SIZE]; UCHAR iv[TEE_FS_HTREE_IV_SIZE]; UCHAR tag[TEE_FS_HTREE_TAG_SIZE]; USHORT flags; }tee_fs_htree_node_image; //-------------------------------------- LittleEndian(); tee_fs_htree_image ver0_head; tee_fs_htree_image ver1_head; FSeek(0x1000); tee_fs_htree_node_image ver0_root_node; tee_fs_htree_node_image ver1_root_node; FSeek(0x2000); ","date":"2023-09-25","objectID":"/optee_template/:1:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["tee"],"content":"encrypted ta //------------------------------------------------ //--- 010 Editor v10.0.2 Binary Template // // File: // Authors: // Version: // Purpose: // Category: // File Mask: // ID Bytes: // History: //------------------------------------------------ enum shdr_img_type { SHDR_TA = 0, SHDR_BOOTSTRAP_TA = 1, SHDR_ENCRYPTED_TA = 2, }; #define SHDR_MAGIC 0x4f545348 /** * struct shdr - signed header * @magic: magic number must match SHDR_MAGIC * @img_type: image type, values defined by enum shdr_img_type * @img_size: image size in bytes * @algo: algorithm, defined by public key algorithms TEE_ALG_* * from TEE Internal API specification * @hash_size: size of the signed hash * @sig_size: size of the signature * @hash: hash of an image * @sig: signature of @hash */ struct shdr { UINT32 magic; UINT32 img_type; UINT32 img_size; UINT32 algo; USHORT hash_size; USHORT sig_size; /* * Commented out element used to visualize the layout dynamic part * of the struct. * * hash is accessed through the macro SHDR_GET_HASH and * signature is accessed through the macro SHDR_GET_SIG * * UCHAR hash[hash_size]; * UCHAR sig[sig_size]; */ }; /** * struct shdr_bootstrap_ta - bootstrap TA subheader * @uuid: UUID of the TA * @ta_version: Version of the TA */ struct shdr_bootstrap_ta { UCHAR uuid[16]; UINT32 ta_version; }; /** * struct shdr_encrypted_ta - encrypted TA header * @enc_algo: authenticated encyption algorithm, defined by symmetric key * algorithms TEE_ALG_* from TEE Internal API * specification * @flags: authenticated encyption flags * @iv_size: size of the initialization vector * @tag_size: size of the authentication tag * @iv: initialization vector * @tag: authentication tag */ struct shdr_encrypted_ta { UINT32 enc_algo; UINT32 flags; USHORT iv_size; USHORT tag_size; /* * Commented out element used to visualize the layout dynamic part * of the struct. * * iv is accessed through the macro SHDR_ENC_GET_IV and * tag is accessed through the macro SHDR_ENC_GET_TAG * * UCHAR iv[iv_size]; * UCHAR tag[tag_size]; */ }; #define SHDR_ENC_KEY_TYPE_MASK 0x1 enum shdr_enc_key_type { SHDR_ENC_KEY_DEV_SPECIFIC = 0, SHDR_ENC_KEY_CLASS_WIDE = 1, }; #define HASH_SIZE 32 #define TAG_SIZE 16 #define SIG_SIZE 256 #define IV_SIZE 12 /* nonce = \u003cunique random value\u003e ciphertext, tag = AES_GCM(\u003cstripped ELF\u003e) hash = H(\u003cstruct shdr\u003e || \u003cstruct shdr_bootstrap_ta\u003e || \u003cstruct shdr_encrypted_ta\u003e || \u003cnonce\u003e || \u003ctag\u003e || \u003cstripped ELF\u003e) signature = RSA-Sign(\u003chash\u003e) encrypted_binary = \u003cstruct shdr\u003e || \u003chash\u003e || \u003csignature\u003e || \u003cstruct shdr_bootstrap_ta\u003e || \u003cstruct shdr_encrypted_ta\u003e || \u003cnonce\u003e || \u003ctag\u003e || \u003cciphertext\u003e */ LittleEndian(); shdr head_shdr; UCHAR hash[HASH_SIZE]; UCHAR sig[SIG_SIZE]; shdr_bootstrap_ta bootstrap_ta; shdr_encrypted_ta encrypted_ta; UCHAR nonce[IV_SIZE]; UCHAR tag[TAG_SIZE]; ","date":"2023-09-25","objectID":"/optee_template/:2:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["tee"],"content":"decrypt script from cryptography.hazmat.primitives.ciphers.aead import AESGCM import struct import sys f = open(sys.argv[1], 'rb') shdr = f.read(20) (magic, img_type, img_size, algo, digest_len, sig_len) = struct.unpack('\u003cIIIIHH', shdr) # private key key = 'b64d239b1f3c7d3b06506229cd8ff7c8af2bb4db2168621ac62c84948468c4f4' # hash = f.read(32) sig = f.read(256) shdr_bootstrap_ta = f.read(20) shdr_encrypted_ta = f.read(12) nonce = f.read(12) tag = f.read(16) cipher = f.read() print(len(cipher)) f.close() print(f\"nonce: {nonce}\") print(f\"tag: {tag}\") gcm = AESGCM(bytes.fromhex(key)) plain = gcm.decrypt(nonce, cipher+tag, None) f = open('dec.ta', 'wb') f.write(plain) f.close() ","date":"2023-09-25","objectID":"/optee_template/:3:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["tee"],"content":"ida typedef unsigned int size_t; enum TEEC_ParamType { TEEC_NONE = 0x0, /* unused parameter */ TEEC_VALUE_INPUT = 0x01, /* input type of value, refer TEEC_Value */ TEEC_VALUE_OUTPUT = 0x02, /* output type of value, refer TEEC_Value */ TEEC_VALUE_INOUT = 0x03, /* value is used as both input and output, refer TEEC_Value */ TEEC_MEMREF_TEMP_INPUT = 0x05, /* input type of temp memory reference, refer TEEC_TempMemoryReference */ TEEC_MEMREF_TEMP_OUTPUT = 0x06, /* output type of temp memory reference, refer TEEC_TempMemoryReference */ TEEC_MEMREF_TEMP_INOUT = 0x07, /* temp memory reference used as both input and output, refer TEEC_TempMemoryReference */ TEEC_ION_INPUT = 0x08, /* input type of icon memory reference, refer TEEC_IonReference */ TEEC_ION_SGLIST_INPUT = 0x09, /* input type of ion memory block reference, refer TEEC_IonSglistReference */ TEEC_MEMREF_SHARED_INOUT = 0x0a, /* no copy mem */ TEEC_MEMREF_WHOLE = 0xc, /* use whole memory block, refer TEEC_RegisteredMemoryReference */ TEEC_MEMREF_PARTIAL_INPUT = 0xd, /* input type of memory reference, refer TEEC_RegisteredMemoryReference */ TEEC_MEMREF_PARTIAL_OUTPUT = 0xe, /* output type of memory reference, refer TEEC_RegisteredMemoryReference */ TEEC_MEMREF_PARTIAL_INOUT = 0xf /* memory reference used as both input and output, refer TEEC_RegisteredMemoryReference */ }; struct TEE_VALUE_Param { size_t a; size_t b; }; struct TEE_MEMREF_Param { void *buffer; size_t size; }; union TEE_Param { struct TEE_VALUE_Param value; struct TEE_MEMREF_Param memref; }; ","date":"2023-09-25","objectID":"/optee_template/:4:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["pwn"],"content":"cpio gcc -o exp -static exp.c -masm=intel -s -lpthread mv ./exp ./initramfs cd initramfs find . -print0 \\ | cpio --null -ov --format=newc \\ | gzip -9 \u003e ../initramfs.cpio.gz cd .. ","date":"2023-09-25","objectID":"/kernel/:1:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"mount # ext4 sudo mount -o rw -osync -o auto -o exec rootfs.img rootfs ","date":"2023-09-25","objectID":"/kernel/:2:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"模板 #define _GNU_SOURCE #include \u003cassert.h\u003e #include \u003cfcntl.h\u003e #include \u003cpoll.h\u003e #include \u003csched.h\u003e #include \u003csignal.h\u003e #include \u003cstdbool.h\u003e #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/ioctl.h\u003e #include \u003csys/mman.h\u003e #include \u003csys/prctl.h\u003e #include \u003csys/ptrace.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/types.h\u003e #include \u003csys/user.h\u003e #include \u003csys/utsname.h\u003e #include \u003csys/wait.h\u003e #include \u003csyscall.h\u003e #include \u003cunistd.h\u003e #define COLOR_GREEN \"\\033[32m\" #define COLOR_RED \"\\033[31m\" #define COLOR_YELLOW \"\\033[33m\" #define COLOR_DEFAULT \"\\033[0m\" #define logd(fmt, ...) \\ dprintf(2, \"[*] %s:%d \" fmt \"\\n\", __FILE__, __LINE__, ##__VA_ARGS__) #define logi(fmt, ...) \\ dprintf(2, COLOR_GREEN \"[+] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__) #define logw(fmt, ...) \\ dprintf(2, COLOR_YELLOW \"[!] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__) #define loge(fmt, ...) \\ dprintf(2, COLOR_RED \"[-] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__) #define die(fmt, ...) \\ do { \\ loge(fmt, ##__VA_ARGS__); \\ loge(\"Exit at line %d\", __LINE__); \\ exit(1); \\ } while (0) #define o(x) (kbase + x) size_t pop_rdi = 0x2c9d; size_t commit_creds = 0xbb5b0; size_t init_cred = 0x1a4cbf8; size_t swapgs_restore_regs_and_return_to_usermode = 0x1000f01; size_t prepare_kernel_cred = 0xf8520; unsigned long user_cs, user_ss, user_eflags, user_sp, user_ip; void get_shell() { int uid; if (!(uid = getuid())) { logi(\"root get!!\"); execl(\"/bin/sh\", \"sh\", NULL); } else { die(\"gain root failed, uid: %d\", uid); } } void saveStatus(void) { __asm__(\"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_eflags;\" ); user_ip = (uint64_t)\u0026get_shell; user_sp = 0xf000 + (uint64_t)mmap(0, 0x10000, 6, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); } void bind_cpu(int cpu_idx) { cpu_set_t my_set; CPU_ZERO(\u0026my_set); CPU_SET(cpu_idx, \u0026my_set); if (sched_setaffinity(0, sizeof(cpu_set_t), \u0026my_set)) { die(\"sched_setaffinity: %m\"); } } void hexdump(const void *data, size_t size) { char ascii[17]; size_t i, j; ascii[16] = '\\0'; for (i = 0; i \u003c size; ++i) { dprintf(2, \"%02X \", ((unsigned char *)data)[i]); if (((unsigned char *)data)[i] \u003e= ' ' \u0026\u0026 ((unsigned char *)data)[i] \u003c= '~') { ascii[i % 16] = ((unsigned char *)data)[i]; } else { ascii[i % 16] = '.'; } if ((i + 1) % 8 == 0 || i + 1 == size) { dprintf(2, \" \"); if ((i + 1) % 16 == 0) { dprintf(2, \"| %s \\n\", ascii); } else if (i + 1 == size) { ascii[(i + 1) % 16] = '\\0'; if ((i + 1) % 16 \u003c= 8) { dprintf(2, \" \"); } for (j = (i + 1) % 16; j \u003c 16; ++j) { dprintf(2, \" \"); } dprintf(2, \"| %s \\n\", ascii); } } } } size_t kbase; int main() { saveStatus(); int fd = open(\"/dev/seven\", O_RDONLY); if(fd \u003c 0) perror(\"Error open\"); } ","date":"2023-09-25","objectID":"/kernel/:3:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"Codeql for obj import cpp from FunctionCall fc, Function f, int alloc_size, int alloc_flags, PointerType typ where f = fc.getTarget() and // 只查找kalloc和kzalloc类的函数 f.getName().regexpMatch(\"k[a-z]*alloc\") and alloc_size = fc.getArgument(0).getValue().toInt() and // get object in kmalloc-64,128,192 (alloc_size \u003e 32 and alloc_size \u003c= 192) and alloc_flags = fc.getArgument(1).getValue().toInt() and // GFP_ACCOUNT == 0x400000(4194304) alloc_flags.bitAnd(4194304) = 0 and typ = fc.getActualType().(PointerType) and not fc.getEnclosingFunction().getFile().getRelativePath().regexpMatch(\"arch.*\") and not fc.getEnclosingFunction().getFile().getRelativePath().regexpMatch(\"drivers.*\") select fc, \"在 $@ 的 $@ 中发现一处调用 $@ 分配内存，结构体 $@, 大小 \" + alloc_size.toString(), fc,fc.getEnclosingFunction().getFile().getRelativePath(), fc.getEnclosingFunction(), fc.getEnclosingFunction().getName().toString(), fc, f.getName(), typ.getBaseType(), typ.getBaseType().getName() ","date":"2023-09-25","objectID":"/kernel/:4:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"extract-vmlinux #!/bin/sh # SPDX-License-Identifier: GPL-2.0-only # ---------------------------------------------------------------------- # extract-vmlinux - Extract uncompressed vmlinux from a kernel image # # Inspired from extract-ikconfig # (c) 2009,2010 Dick Streefland \u003cdick@streefland.net\u003e # # (c) 2011 Corentin Chary \u003ccorentin.chary@gmail.com\u003e # # ---------------------------------------------------------------------- check_vmlinux() { # Use readelf to check if it's a valid ELF # TODO: find a better to way to check that it's really vmlinux # and not just an elf readelf -h $1 \u003e /dev/null 2\u003e\u00261 || return 1 cat $1 exit 0 } try_decompress() { # The obscure use of the \"tr\" filter is to work around older versions of # \"grep\" that report the byte offset of the line instead of the pattern. # Try to find the header ($1) and decompress from here for pos in `tr \"$1\\n$2\" \"\\n$2=\" \u003c \"$img\" | grep -abo \"^$2\"` do pos=${pos%%:*} tail -c+$pos \"$img\" | $3 \u003e $tmp 2\u003e /dev/null check_vmlinux $tmp done } # Check invocation: me=${0##*/} img=$1 if [ $# -ne 1 -o ! -s \"$img\" ] then echo \"Usage: $me \u003ckernel-image\u003e\" \u003e\u00262 exit 2 fi # Prepare temp files: tmp=$(mktemp /tmp/vmlinux-XXX) trap \"rm -f $tmp\" 0 # That didn't work, so retry after decompression. try_decompress '\\037\\213\\010' xy gunzip try_decompress '\\3757zXZ\\000' abcde unxz try_decompress 'BZh' xy bunzip2 try_decompress '\\135\\0\\0\\0' xxx unlzma try_decompress '\\211\\114\\132' xy 'lzop -d' try_decompress '\\002!L\\030' xxx 'lz4 -d' try_decompress '(\\265/\\375' xxx unzstd # Finally check for uncompressed images or objects: check_vmlinux $img # Bail out: echo \"$me: Cannot find vmlinux.\" \u003e\u00262 ","date":"2023-09-25","objectID":"/kernel/:5:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["code"],"content":"前几天群里提到的问题，简单记录下查阅到的方法。 ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:0:0","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["code"],"content":"在C中调用汇编中定义的函数 以Linux x86为例，用汇编语言编写一个hello_world函数，输出”Hello, World!\\n”为例，其不需要任何参数，同时也没有返回值，相应的汇编代码如下： .globl hello_world .type hello_world, @function .section .data message: .ascii \"Hello, World!\\n\" length: .int . - message .section .text hello_world: mov $4, %eax mov $1, %ebx mov $message, %ecx mov length, %edx int $0x80 ret 由于使用gcc进行编译，因此汇编代码中使用AT\u0026T语法。如果在用gcc编译时加上-masm=intel 选项，则可以使用intel语法。当然，也可以使用nasm对汇编语言进行汇编。 然后编写一个C程序调用该函数，如下： // gcc -m32 hello_world.c hello_world.s -o hello_world extern void hello_world(); void main() { hello_world(); } 下面通过参数传递将”Hello World!”传入到汇编代码中，修改如下： .globl hello_world .type hello_world, @function .section .text hello_world: mov $4, %eax mov $1, %ebx mov 4(%esp), %ecx mov $0xd, %edx int $0x80 ret 对应的C程序如下： extern void hello_world(char* value); void main() { hello_world(\"Hello World!\\n\"); } ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:1:0","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["code"],"content":"在汇编中调用C中的函数 以printf为例，通过在汇编代码中调用printf()函数，示例代码如下： .extern printf .globl main .section .data message: .ascii \"hello,world!\\n\" format: .ascii \"%s\" .section .text main: push $message push $format mov $0, %eax call printf add $0x8, %esp ret 使用gcc编译汇编代码时，开始符号不再是_start而是main。由于main是一个函数，所以在最后必须要有ret指令； 在调用函数之前，寄存器eax/rax的值必须设为0。 ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:1:1","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["code"],"content":"在C中嵌入汇编 #include \u003cstdio.h\u003e int sum(int a, int b) { asm(\"addl %edi, %esi\"); asm(\"movl %esi, %eax\"); } int main() { printf(\"%d\\n\", sum(2, 3)); return 0; } 在上面的示例代码中，也可以将多条汇编指令写在一起，如下： asm( \"addl %edi, %esi\\n\\r\" \"movl %esi, %eax\\n\\r\" ); ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:2:0","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["pwn"],"content":"USE ADB in WSL # ADB export PATH=\"$PATH:/mnt/d/Tools/Android/SDK/platform-tools\" alias adb=\"/mnt/d/Tools/Android/SDK/platform-tools/adb.exe\" 由于将adb的路径alias后，默认在sh中是找不到的，若想在sh脚本中使用ADB，需在脚本前添加以下代码: #!/bin/bash -i shopt -s expand_aliases ","date":"2023-09-25","objectID":"/adb/:1:0","tags":["adb"],"title":"Adb","uri":"/adb/"},{"categories":["pwn"],"content":"Usage adb push ready_to_push path adb pull path_to_want # if read-only system adb remout ","date":"2023-09-25","objectID":"/adb/:2:0","tags":["adb"],"title":"Adb","uri":"/adb/"},{"categories":["misc"],"content":"exp from pwn import * import sys context.log_level = \"debug\" if len(sys.argv) \u003c 2: debug = True else: debug = False if debug: p = process(\"./\") libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") else: p = remote(\"\",) libc = ELF(\"./libc-2.31.so\") ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\"b *$rebase({b})\".format(b = hex(b))) else: gdb.attach(p) #context.terminal = ['tmux', 'splitw', '-h'] p.interactive() ","date":"2023-09-25","objectID":"/misc/:1:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"查找错误git commit git bisect ","date":"2023-09-25","objectID":"/misc/:2:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"Debug Multithreading # gdb set follow-fork-mode [parent|child] # 设置调试[父进程/子进程] set detach-on-fork [on|off] # 未调试进程[继续执行/block在fork位置] show follow-fork-mode show detach-on-fork info inferiors # 查看正在调试的进程信息 info threads # 查询线程 thread \u003cthread number\u003e # 切换线程 strace -ff -o test.txt ./your_binary ","date":"2023-09-25","objectID":"/misc/:3:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"hex dump void hexdump(const void *data, size_t size) { char ascii[17]; size_t i, j; ascii[16] = '\\0'; for (i = 0; i \u003c size; ++i) { dprintf(2, \"%02X \", ((unsigned char *)data)[i]); if (((unsigned char *)data)[i] \u003e= ' ' \u0026\u0026 ((unsigned char *)data)[i] \u003c= '~') { ascii[i % 16] = ((unsigned char *)data)[i]; } else { ascii[i % 16] = '.'; } if ((i + 1) % 8 == 0 || i + 1 == size) { dprintf(2, \" \"); if ((i + 1) % 16 == 0) { dprintf(2, \"| %s \\n\", ascii); } else if (i + 1 == size) { ascii[(i + 1) % 16] = '\\0'; if ((i + 1) % 16 \u003c= 8) { dprintf(2, \" \"); } for (j = (i + 1) % 16; j \u003c 16; ++j) { dprintf(2, \" \"); } dprintf(2, \"| %s \\n\", ascii); } } } } ","date":"2023-09-25","objectID":"/misc/:4:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"ropper ropper --file ./vmlinux --nocolor \u003e gadgets.txt ","date":"2023-09-25","objectID":"/misc/:5:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"pow #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cmemory.h\u003e #include \u003cstdint.h\u003e #include \u003copenssl/sha.h\u003e #define PREFIX_LEN 10 int main(int argc, char const *argv[]) { if (argc != 2 || strlen(argv[1]) != PREFIX_LEN) return -1; uint8_t buf[32]; uint8_t out[SHA256_DIGEST_LENGTH]; memcpy(buf, argv[1], PREFIX_LEN); for (uint64_t i = 0; i \u003c 0xffffffffffff; ++i) { sprintf(buf + PREFIX_LEN, \"%lu\", i); SHA256(buf, strlen(buf), out); if (out[0] == 0 \u0026\u0026 out[1] == 0 \u0026\u0026 out[2] == 0 \u0026\u0026 (out[3] \u003e\u003e 5) == 0) { printf(\"%s\\n\", buf+10); break; } } return 0; } // gcc -O2 pow.c -lcrypto \u0026\u0026 ./a.out pzlYZX5ZEb \u0026\u0026 rm ./a.out python: from Crypto.Util.number import getPrime,bytes_to_long from pwn import * from parse import * from pwnlib.util.iters import bruteforce from hashlib import sha256 def brute_force(prefix,s): return bruteforce(lambda x:sha256((prefix+x).encode()).hexdigest()==s,string.ascii_letters+string.digits,length=4,method='fixed') p=remote('52.163.228.53', 8081) data = p.recvline()[:-1] prefix, s = parse(\"sha256(xxxx+{}) == {}\",data.decode()) p.sendline(brute_force(prefix,s)) p.interactive() ","date":"2023-09-25","objectID":"/misc/:6:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"docker docker rm -f `docker ps -a -q` ","date":"2023-09-25","objectID":"/misc/:7:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"自定义传参规则 void __usercall xxxxx(char* a1@\u003crdi\u003e) ","date":"2023-09-25","objectID":"/misc/:7:1","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"修改ida字符串显示 # puts(aStr) ---\u003e puts(\"str\") change str seg -\u003e r_x ","date":"2023-09-25","objectID":"/misc/:7:2","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"musl-gcc for kernel # we cannot compile the exploit using musl-gcc, which produces small binary. The problem is that it seems that musl-gcc cannot find the \u003clinux/xxx.h\u003e header files. I solved this by preprocessing exploit using gcc -E and compiling the preprocessing output using musl-gcc gcc -E exp.c -o fs/exp.c musl-gcc -static fs/exp.c -o fs/exp ","date":"2023-09-25","objectID":"/misc/:8:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"remote exp upload from pwn import * import base64 context.log_level = \"debug\" with open(\"./exp\", \"rb\") as f: exp = base64.b64encode(f.read()) def do_pow(r): cmd = r.recvline()[:-1] rr = os.popen(cmd.decode()) r.sendline(rr.read()) p = remote('babypf.seccon.games',9009) do_pow(p) try_count = 1 while True: log.info(\"no.\" + str(try_count) + \" time(s)\") p.sendline() p.recvuntil(\"/ $\") count = 0 for i in range(0, len(exp), 0x200): p.sendline(\"echo -n \\\"\" + exp[i:i + 0x200].decode() + \"\\\" \u003e\u003e /tmp/b64_exp\") count += 1 for i in range(count): p.recvuntil(\"/ $\") p.sendline(\"cat /tmp/b64_exp | base64 -d \u003e /tmp/exploit\") p.sendline(\"chmod +x /tmp/exploit\") randomization = (try_count % 1024) * 0x100000 log.info('trying randomization: ' + hex(randomization)) if not p.recvuntil(b\"Rebooting in 1 seconds..\", timeout=20): break log.warn('failed!') try_count += 1 log.success('success to get the root shell!') p.interactive() ","date":"2023-09-25","objectID":"/misc/:9:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"debug # debug.sh gdb qemu-system-x86_64 --pid `ps -ef | grep qemu | awk '{print $2}' | head -n 1` -x ./debug.source # debug.source b *addr c ","date":"2023-09-25","objectID":"/misc/:10:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"tmux set-option -g mouse on # 开启鼠标支持 setw -g mode-keys vi # 支持vi模式 set-option -s set-clipboard on # 开启系统剪切板支持 ## 鼠标滚轮模拟 # Emulate scrolling by sending up and down keys if these commands are running in the pane tmux_commands_with_legacy_scroll=\"nano less more man\" bind-key -T root WheelUpPane \\ if-shell -Ft= '#{?mouse_any_flag,1,#{pane_in_mode}}' \\ 'send -Mt=' \\ 'if-shell -t= \"#{?alternate_on,true,false} || echo \\\"#{tmux_commands_with_legacy_scroll}\\\" | grep -q \\\"#{pane_current_command}\\\"\" \\ \"send -t= Up Up Up\" \"copy-mode -et=\"' bind-key -T root WheelDownPane \\ if-shell -Ft = '#{?pane_in_mode,1,#{mouse_any_flag}}' \\ 'send -Mt=' \\ 'if-shell -t= \"#{?alternate_on,true,false} || echo \\\"#{tmux_commands_with_legacy_scroll}\\\" | grep -q \\\"#{pane_current_command}\\\"\" \\ \"send -t= Down Down Down\" \"send -Mt=\"' ","date":"2023-09-25","objectID":"/misc/:11:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"patchelf patchelf --set-interpreter ld_path xxx patchelf --set-rpath libc_dir xxx ","date":"2023-09-25","objectID":"/misc/:12:0","tags":["misc"],"title":"Misc","uri":"/misc/"}]