[{"categories":["pwn"],"content":"adb adb devices # 查看设备 adb shell ","date":"2024-02-19","objectID":"/apk/:1:0","tags":["adb"],"title":"Apk杂记","uri":"/apk/"},{"categories":["pwn"],"content":"ida调试so 一般断在Jni_onload adb forward tcp:23946 tcp:23946 adb shell cd /data/local/tmp ./androidserver androidserver的位数应该和so对应，不过跑以下看能不能搜到进程就知道了。 ida侧选择Debugger-\u003eattach-\u003eRemote ARM Linux/Android debugger，选择attach，找到app进程attach上就行。 ","date":"2024-02-19","objectID":"/apk/:2:0","tags":["adb"],"title":"Apk杂记","uri":"/apk/"},{"categories":["pwn"],"content":"jdwp am start -D -n com.bin.MathGame/.MainActivity 在手机上执行 ps -ef | grep mathgame # getpid adb forward tcp:8700 jdwp:{pid} jdb -connect “com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700” ","date":"2024-02-19","objectID":"/apk/:3:0","tags":["adb"],"title":"Apk杂记","uri":"/apk/"},{"categories":["pwn"],"content":"jeb https://bbs.pediy.com/thread-268316.htm ","date":"2024-02-19","objectID":"/apk/:4:0","tags":["adb"],"title":"Apk杂记","uri":"/apk/"},{"categories":["pwn"],"content":"frida ","date":"2024-02-19","objectID":"/apk/:5:0","tags":["adb"],"title":"Apk杂记","uri":"/apk/"},{"categories":["pwn"],"content":"frida-hexdump 用来dump运行时的dex，常用于脱壳。 pip3 install frida-dexdump adb forward tcp:27042 tcp:27042 adb forward tcp:27043 tcp:27043 # 运行app frida-dexdump -FU 使用d2j_dex2jar反编译，然后拖入jadx分析。 ","date":"2024-02-19","objectID":"/apk/:5:1","tags":["adb"],"title":"Apk杂记","uri":"/apk/"},{"categories":["pwn"],"content":"frida_hook_libart https://github.com/lasting-yang/frida_hook_libart 可以查看动态注册的jni_onload frida -U -f package_name -l hook_RegisterNatives.js ","date":"2024-02-19","objectID":"/apk/:6:0","tags":["adb"],"title":"Apk杂记","uri":"/apk/"},{"categories":["tee"],"content":"ta //------------------------------------------------ //--- 010 Editor v10.0.2 Binary Template // // File: // Authors: // Version: // Purpose: // Category: // File Mask: // ID Bytes: // History: //------------------------------------------------ #define TEE_FS_HTREE_IV_SIZE 16 #define TEE_FS_HTREE_TAG_SIZE 16 #define TEE_FS_HTREE_FEK_SIZE 16 typedef struct _tee_fs_htree_meta { UINT64 length; }tee_fs_htree_meta; typedef struct _tee_fs_htree_imeta { struct tee_fs_htree_meta meta; UINT32 max_node_id; UINT32 nop; }tee_fs_htree_imeta; typedef struct _tee_fs_htree_image { UCHAR iv[TEE_FS_HTREE_IV_SIZE]; UCHAR tag[TEE_FS_HTREE_TAG_SIZE]; UCHAR enc_fek[TEE_FS_HTREE_FEK_SIZE]; UCHAR imeta[sizeof(struct tee_fs_htree_imeta)]; UINT32 counter; }tee_fs_htree_image; #define TEE_FS_HTREE_HASH_SIZE 32 #define TEE_FS_HTREE_IV_SIZE 16 #define TEE_FS_HTREE_TAG_SIZE 16 typedef struct _tee_fs_htree_node_image { /* Note that calc_node_hash() depends on hash first in struct */ UCHAR hash[TEE_FS_HTREE_HASH_SIZE]; UCHAR iv[TEE_FS_HTREE_IV_SIZE]; UCHAR tag[TEE_FS_HTREE_TAG_SIZE]; USHORT flags; }tee_fs_htree_node_image; //-------------------------------------- LittleEndian(); tee_fs_htree_image ver0_head; tee_fs_htree_image ver1_head; FSeek(0x1000); tee_fs_htree_node_image ver0_root_node; tee_fs_htree_node_image ver1_root_node; FSeek(0x2000); ","date":"2023-09-25","objectID":"/optee_template/:1:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["tee"],"content":"encrypted ta //------------------------------------------------ //--- 010 Editor v10.0.2 Binary Template // // File: // Authors: // Version: // Purpose: // Category: // File Mask: // ID Bytes: // History: //------------------------------------------------ enum shdr_img_type { SHDR_TA = 0, SHDR_BOOTSTRAP_TA = 1, SHDR_ENCRYPTED_TA = 2, }; #define SHDR_MAGIC 0x4f545348 /** * struct shdr - signed header * @magic: magic number must match SHDR_MAGIC * @img_type: image type, values defined by enum shdr_img_type * @img_size: image size in bytes * @algo: algorithm, defined by public key algorithms TEE_ALG_* * from TEE Internal API specification * @hash_size: size of the signed hash * @sig_size: size of the signature * @hash: hash of an image * @sig: signature of @hash */ struct shdr { UINT32 magic; UINT32 img_type; UINT32 img_size; UINT32 algo; USHORT hash_size; USHORT sig_size; /* * Commented out element used to visualize the layout dynamic part * of the struct. * * hash is accessed through the macro SHDR_GET_HASH and * signature is accessed through the macro SHDR_GET_SIG * * UCHAR hash[hash_size]; * UCHAR sig[sig_size]; */ }; /** * struct shdr_bootstrap_ta - bootstrap TA subheader * @uuid: UUID of the TA * @ta_version: Version of the TA */ struct shdr_bootstrap_ta { UCHAR uuid[16]; UINT32 ta_version; }; /** * struct shdr_encrypted_ta - encrypted TA header * @enc_algo: authenticated encyption algorithm, defined by symmetric key * algorithms TEE_ALG_* from TEE Internal API * specification * @flags: authenticated encyption flags * @iv_size: size of the initialization vector * @tag_size: size of the authentication tag * @iv: initialization vector * @tag: authentication tag */ struct shdr_encrypted_ta { UINT32 enc_algo; UINT32 flags; USHORT iv_size; USHORT tag_size; /* * Commented out element used to visualize the layout dynamic part * of the struct. * * iv is accessed through the macro SHDR_ENC_GET_IV and * tag is accessed through the macro SHDR_ENC_GET_TAG * * UCHAR iv[iv_size]; * UCHAR tag[tag_size]; */ }; #define SHDR_ENC_KEY_TYPE_MASK 0x1 enum shdr_enc_key_type { SHDR_ENC_KEY_DEV_SPECIFIC = 0, SHDR_ENC_KEY_CLASS_WIDE = 1, }; #define HASH_SIZE 32 #define TAG_SIZE 16 #define SIG_SIZE 256 #define IV_SIZE 12 /* nonce = \u003cunique random value\u003e ciphertext, tag = AES_GCM(\u003cstripped ELF\u003e) hash = H(\u003cstruct shdr\u003e || \u003cstruct shdr_bootstrap_ta\u003e || \u003cstruct shdr_encrypted_ta\u003e || \u003cnonce\u003e || \u003ctag\u003e || \u003cstripped ELF\u003e) signature = RSA-Sign(\u003chash\u003e) encrypted_binary = \u003cstruct shdr\u003e || \u003chash\u003e || \u003csignature\u003e || \u003cstruct shdr_bootstrap_ta\u003e || \u003cstruct shdr_encrypted_ta\u003e || \u003cnonce\u003e || \u003ctag\u003e || \u003cciphertext\u003e */ LittleEndian(); shdr head_shdr; UCHAR hash[HASH_SIZE]; UCHAR sig[SIG_SIZE]; shdr_bootstrap_ta bootstrap_ta; shdr_encrypted_ta encrypted_ta; UCHAR nonce[IV_SIZE]; UCHAR tag[TAG_SIZE]; ","date":"2023-09-25","objectID":"/optee_template/:2:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["tee"],"content":"decrypt script from cryptography.hazmat.primitives.ciphers.aead import AESGCM import struct import sys f = open(sys.argv[1], 'rb') shdr = f.read(20) (magic, img_type, img_size, algo, digest_len, sig_len) = struct.unpack('\u003cIIIIHH', shdr) # private key key = 'b64d239b1f3c7d3b06506229cd8ff7c8af2bb4db2168621ac62c84948468c4f4' # hash = f.read(32) sig = f.read(256) shdr_bootstrap_ta = f.read(20) shdr_encrypted_ta = f.read(12) nonce = f.read(12) tag = f.read(16) cipher = f.read() print(len(cipher)) f.close() print(f\"nonce: {nonce}\") print(f\"tag: {tag}\") gcm = AESGCM(bytes.fromhex(key)) plain = gcm.decrypt(nonce, cipher+tag, None) f = open('dec.ta', 'wb') f.write(plain) f.close() ","date":"2023-09-25","objectID":"/optee_template/:3:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["tee"],"content":"ida typedef unsigned int size_t; enum TEEC_ParamType { TEEC_NONE = 0x0, /* unused parameter */ TEEC_VALUE_INPUT = 0x01, /* input type of value, refer TEEC_Value */ TEEC_VALUE_OUTPUT = 0x02, /* output type of value, refer TEEC_Value */ TEEC_VALUE_INOUT = 0x03, /* value is used as both input and output, refer TEEC_Value */ TEEC_MEMREF_TEMP_INPUT = 0x05, /* input type of temp memory reference, refer TEEC_TempMemoryReference */ TEEC_MEMREF_TEMP_OUTPUT = 0x06, /* output type of temp memory reference, refer TEEC_TempMemoryReference */ TEEC_MEMREF_TEMP_INOUT = 0x07, /* temp memory reference used as both input and output, refer TEEC_TempMemoryReference */ TEEC_ION_INPUT = 0x08, /* input type of icon memory reference, refer TEEC_IonReference */ TEEC_ION_SGLIST_INPUT = 0x09, /* input type of ion memory block reference, refer TEEC_IonSglistReference */ TEEC_MEMREF_SHARED_INOUT = 0x0a, /* no copy mem */ TEEC_MEMREF_WHOLE = 0xc, /* use whole memory block, refer TEEC_RegisteredMemoryReference */ TEEC_MEMREF_PARTIAL_INPUT = 0xd, /* input type of memory reference, refer TEEC_RegisteredMemoryReference */ TEEC_MEMREF_PARTIAL_OUTPUT = 0xe, /* output type of memory reference, refer TEEC_RegisteredMemoryReference */ TEEC_MEMREF_PARTIAL_INOUT = 0xf /* memory reference used as both input and output, refer TEEC_RegisteredMemoryReference */ }; struct TEE_VALUE_Param { size_t a; size_t b; }; struct TEE_MEMREF_Param { void *buffer; size_t size; }; union TEE_Param { struct TEE_VALUE_Param value; struct TEE_MEMREF_Param memref; }; ","date":"2023-09-25","objectID":"/optee_template/:4:0","tags":["tee","optee"],"title":"Optee_template","uri":"/optee_template/"},{"categories":["pwn"],"content":"cpio gcc -o exp -static exp.c -masm=intel -s -lpthread mv ./exp ./initramfs cd initramfs find . -print0 \\ | cpio --null -ov --format=newc \\ | gzip -9 \u003e ../initramfs.cpio.gz cd .. ","date":"2023-09-25","objectID":"/kernel/:1:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"mount # ext4 sudo mount -o rw -osync -o auto -o exec rootfs.img rootfs ","date":"2023-09-25","objectID":"/kernel/:2:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"模板 #define _GNU_SOURCE #include \u003cassert.h\u003e #include \u003cfcntl.h\u003e #include \u003cpoll.h\u003e #include \u003csched.h\u003e #include \u003csignal.h\u003e #include \u003cstdbool.h\u003e #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/ioctl.h\u003e #include \u003csys/mman.h\u003e #include \u003csys/prctl.h\u003e #include \u003csys/ptrace.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/types.h\u003e #include \u003csys/user.h\u003e #include \u003csys/utsname.h\u003e #include \u003csys/wait.h\u003e #include \u003csyscall.h\u003e #include \u003cunistd.h\u003e #define COLOR_GREEN \"\\033[32m\" #define COLOR_RED \"\\033[31m\" #define COLOR_YELLOW \"\\033[33m\" #define COLOR_DEFAULT \"\\033[0m\" #define logd(fmt, ...) \\ dprintf(2, \"[*] %s:%d \" fmt \"\\n\", __FILE__, __LINE__, ##__VA_ARGS__) #define logi(fmt, ...) \\ dprintf(2, COLOR_GREEN \"[+] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__) #define logw(fmt, ...) \\ dprintf(2, COLOR_YELLOW \"[!] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__) #define loge(fmt, ...) \\ dprintf(2, COLOR_RED \"[-] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__) #define die(fmt, ...) \\ do { \\ loge(fmt, ##__VA_ARGS__); \\ loge(\"Exit at line %d\", __LINE__); \\ exit(1); \\ } while (0) #define o(x) (kbase + x) size_t pop_rdi = 0x2c9d; size_t commit_creds = 0xbb5b0; size_t init_cred = 0x1a4cbf8; size_t swapgs_restore_regs_and_return_to_usermode = 0x1000f01; size_t prepare_kernel_cred = 0xf8520; unsigned long user_cs, user_ss, user_eflags, user_sp, user_ip; void get_shell() { int uid; if (!(uid = getuid())) { logi(\"root get!!\"); execl(\"/bin/sh\", \"sh\", NULL); } else { die(\"gain root failed, uid: %d\", uid); } } void saveStatus(void) { __asm__(\"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_eflags;\" ); user_ip = (uint64_t)\u0026get_shell; user_sp = 0xf000 + (uint64_t)mmap(0, 0x10000, 6, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); } void bind_cpu(int cpu_idx) { cpu_set_t my_set; CPU_ZERO(\u0026my_set); CPU_SET(cpu_idx, \u0026my_set); if (sched_setaffinity(0, sizeof(cpu_set_t), \u0026my_set)) { die(\"sched_setaffinity: %m\"); } } void hexdump(const void *data, size_t size) { char ascii[17]; size_t i, j; ascii[16] = '\\0'; for (i = 0; i \u003c size; ++i) { dprintf(2, \"%02X \", ((unsigned char *)data)[i]); if (((unsigned char *)data)[i] \u003e= ' ' \u0026\u0026 ((unsigned char *)data)[i] \u003c= '~') { ascii[i % 16] = ((unsigned char *)data)[i]; } else { ascii[i % 16] = '.'; } if ((i + 1) % 8 == 0 || i + 1 == size) { dprintf(2, \" \"); if ((i + 1) % 16 == 0) { dprintf(2, \"| %s \\n\", ascii); } else if (i + 1 == size) { ascii[(i + 1) % 16] = '\\0'; if ((i + 1) % 16 \u003c= 8) { dprintf(2, \" \"); } for (j = (i + 1) % 16; j \u003c 16; ++j) { dprintf(2, \" \"); } dprintf(2, \"| %s \\n\", ascii); } } } } size_t kbase; int main() { saveStatus(); int fd = open(\"/dev/seven\", O_RDONLY); if(fd \u003c 0) perror(\"Error open\"); } ","date":"2023-09-25","objectID":"/kernel/:3:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"Codeql for obj import cpp from FunctionCall fc, Function f, int alloc_size, int alloc_flags, PointerType typ where f = fc.getTarget() and // 只查找kalloc和kzalloc类的函数 f.getName().regexpMatch(\"k[a-z]*alloc\") and alloc_size = fc.getArgument(0).getValue().toInt() and // get object in kmalloc-64,128,192 (alloc_size \u003e 32 and alloc_size \u003c= 192) and alloc_flags = fc.getArgument(1).getValue().toInt() and // GFP_ACCOUNT == 0x400000(4194304) alloc_flags.bitAnd(4194304) = 0 and typ = fc.getActualType().(PointerType) and not fc.getEnclosingFunction().getFile().getRelativePath().regexpMatch(\"arch.*\") and not fc.getEnclosingFunction().getFile().getRelativePath().regexpMatch(\"drivers.*\") select fc, \"在 $@ 的 $@ 中发现一处调用 $@ 分配内存，结构体 $@, 大小 \" + alloc_size.toString(), fc,fc.getEnclosingFunction().getFile().getRelativePath(), fc.getEnclosingFunction(), fc.getEnclosingFunction().getName().toString(), fc, f.getName(), typ.getBaseType(), typ.getBaseType().getName() ","date":"2023-09-25","objectID":"/kernel/:4:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"extract-vmlinux #!/bin/sh # SPDX-License-Identifier: GPL-2.0-only # ---------------------------------------------------------------------- # extract-vmlinux - Extract uncompressed vmlinux from a kernel image # # Inspired from extract-ikconfig # (c) 2009,2010 Dick Streefland \u003cdick@streefland.net\u003e # # (c) 2011 Corentin Chary \u003ccorentin.chary@gmail.com\u003e # # ---------------------------------------------------------------------- check_vmlinux() { # Use readelf to check if it's a valid ELF # TODO: find a better to way to check that it's really vmlinux # and not just an elf readelf -h $1 \u003e /dev/null 2\u003e\u00261 || return 1 cat $1 exit 0 } try_decompress() { # The obscure use of the \"tr\" filter is to work around older versions of # \"grep\" that report the byte offset of the line instead of the pattern. # Try to find the header ($1) and decompress from here for pos in `tr \"$1\\n$2\" \"\\n$2=\" \u003c \"$img\" | grep -abo \"^$2\"` do pos=${pos%%:*} tail -c+$pos \"$img\" | $3 \u003e $tmp 2\u003e /dev/null check_vmlinux $tmp done } # Check invocation: me=${0##*/} img=$1 if [ $# -ne 1 -o ! -s \"$img\" ] then echo \"Usage: $me \u003ckernel-image\u003e\" \u003e\u00262 exit 2 fi # Prepare temp files: tmp=$(mktemp /tmp/vmlinux-XXX) trap \"rm -f $tmp\" 0 # That didn't work, so retry after decompression. try_decompress '\\037\\213\\010' xy gunzip try_decompress '\\3757zXZ\\000' abcde unxz try_decompress 'BZh' xy bunzip2 try_decompress '\\135\\0\\0\\0' xxx unlzma try_decompress '\\211\\114\\132' xy 'lzop -d' try_decompress '\\002!L\\030' xxx 'lz4 -d' try_decompress '(\\265/\\375' xxx unzstd # Finally check for uncompressed images or objects: check_vmlinux $img # Bail out: echo \"$me: Cannot find vmlinux.\" \u003e\u00262 ","date":"2023-09-25","objectID":"/kernel/:5:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["pwn"],"content":"非预期 mv bin bin1 /bin1/mkdir bin /bin1/chmod 777 bin /bin1/echo \"/bin1/cat /root/flag\" \u003e /bin/umount /bin1/chmod 777 /bin/umount exit ","date":"2023-09-25","objectID":"/kernel/:6:0","tags":["pwn","kernel"],"title":"Kernel","uri":"/kernel/"},{"categories":["code"],"content":"前几天群里提到的问题，简单记录下查阅到的方法。 ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:0:0","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["code"],"content":"在C中调用汇编中定义的函数 以Linux x86为例，用汇编语言编写一个hello_world函数，输出”Hello, World!\\n”为例，其不需要任何参数，同时也没有返回值，相应的汇编代码如下： .globl hello_world .type hello_world, @function .section .data message: .ascii \"Hello, World!\\n\" length: .int . - message .section .text hello_world: mov $4, %eax mov $1, %ebx mov $message, %ecx mov length, %edx int $0x80 ret 由于使用gcc进行编译，因此汇编代码中使用AT\u0026T语法。如果在用gcc编译时加上-masm=intel 选项，则可以使用intel语法。当然，也可以使用nasm对汇编语言进行汇编。 然后编写一个C程序调用该函数，如下： // gcc -m32 hello_world.c hello_world.s -o hello_world extern void hello_world(); void main() { hello_world(); } 下面通过参数传递将”Hello World!”传入到汇编代码中，修改如下： .globl hello_world .type hello_world, @function .section .text hello_world: mov $4, %eax mov $1, %ebx mov 4(%esp), %ecx mov $0xd, %edx int $0x80 ret 对应的C程序如下： extern void hello_world(char* value); void main() { hello_world(\"Hello World!\\n\"); } ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:1:0","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["code"],"content":"在汇编中调用C中的函数 以printf为例，通过在汇编代码中调用printf()函数，示例代码如下： .extern printf .globl main .section .data message: .ascii \"hello,world!\\n\" format: .ascii \"%s\" .section .text main: push $message push $format mov $0, %eax call printf add $0x8, %esp ret 使用gcc编译汇编代码时，开始符号不再是_start而是main。由于main是一个函数，所以在最后必须要有ret指令； 在调用函数之前，寄存器eax/rax的值必须设为0。 ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:1:1","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["code"],"content":"在C中嵌入汇编 #include \u003cstdio.h\u003e int sum(int a, int b) { asm(\"addl %edi, %esi\"); asm(\"movl %esi, %eax\"); } int main() { printf(\"%d\\n\", sum(2, 3)); return 0; } 在上面的示例代码中，也可以将多条汇编指令写在一起，如下： asm( \"addl %edi, %esi\\n\\r\" \"movl %esi, %eax\\n\\r\" ); ","date":"2023-09-25","objectID":"/mixed_c_with_asm/:2:0","tags":["c","asm"],"title":"Mixed_c_with_asm","uri":"/mixed_c_with_asm/"},{"categories":["pwn"],"content":"USE ADB in WSL # ADB export PATH=\"$PATH:/mnt/d/Tools/Android/SDK/platform-tools\" alias adb=\"/mnt/d/Tools/Android/SDK/platform-tools/adb.exe\" 由于将adb的路径alias后，默认在sh中是找不到的，若想在sh脚本中使用ADB，需在脚本前添加以下代码: #!/bin/bash -i shopt -s expand_aliases ","date":"2023-09-25","objectID":"/adb/:1:0","tags":["adb"],"title":"Adb","uri":"/adb/"},{"categories":["pwn"],"content":"Usage adb push ready_to_push path adb pull path_to_want # if read-only system adb remout ","date":"2023-09-25","objectID":"/adb/:2:0","tags":["adb"],"title":"Adb","uri":"/adb/"},{"categories":["misc"],"content":"exp from pwn import * import sys context.log_level = \"debug\" if len(sys.argv) \u003c 2: debug = True else: debug = False if debug: p = process(\"./\") libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") else: p = remote(\"\",) libc = ELF(\"./libc-2.31.so\") ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\"b *$rebase({b})\".format(b = hex(b))) else: gdb.attach(p) #context.terminal = ['tmux', 'splitw', '-h'] p.interactive() ","date":"2023-09-25","objectID":"/misc/:1:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"查找错误git commit git bisect ","date":"2023-09-25","objectID":"/misc/:2:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"Debug Multithreading # gdb set follow-fork-mode [parent|child] # 设置调试[父进程/子进程] set detach-on-fork [on|off] # 未调试进程[继续执行/block在fork位置] show follow-fork-mode show detach-on-fork info inferiors # 查看正在调试的进程信息 info threads # 查询线程 thread \u003cthread number\u003e # 切换线程 strace -ff -o test.txt ./your_binary ","date":"2023-09-25","objectID":"/misc/:3:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"hex dump void hexdump(const void *data, size_t size) { char ascii[17]; size_t i, j; ascii[16] = '\\0'; for (i = 0; i \u003c size; ++i) { dprintf(2, \"%02X \", ((unsigned char *)data)[i]); if (((unsigned char *)data)[i] \u003e= ' ' \u0026\u0026 ((unsigned char *)data)[i] \u003c= '~') { ascii[i % 16] = ((unsigned char *)data)[i]; } else { ascii[i % 16] = '.'; } if ((i + 1) % 8 == 0 || i + 1 == size) { dprintf(2, \" \"); if ((i + 1) % 16 == 0) { dprintf(2, \"| %s \\n\", ascii); } else if (i + 1 == size) { ascii[(i + 1) % 16] = '\\0'; if ((i + 1) % 16 \u003c= 8) { dprintf(2, \" \"); } for (j = (i + 1) % 16; j \u003c 16; ++j) { dprintf(2, \" \"); } dprintf(2, \"| %s \\n\", ascii); } } } } ","date":"2023-09-25","objectID":"/misc/:4:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"ropper ropper --file ./vmlinux --nocolor \u003e gadgets.txt ","date":"2023-09-25","objectID":"/misc/:5:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"pow #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cmemory.h\u003e #include \u003cstdint.h\u003e #include \u003copenssl/sha.h\u003e #define PREFIX_LEN 10 int main(int argc, char const *argv[]) { if (argc != 2 || strlen(argv[1]) != PREFIX_LEN) return -1; uint8_t buf[32]; uint8_t out[SHA256_DIGEST_LENGTH]; memcpy(buf, argv[1], PREFIX_LEN); for (uint64_t i = 0; i \u003c 0xffffffffffff; ++i) { sprintf(buf + PREFIX_LEN, \"%lu\", i); SHA256(buf, strlen(buf), out); if (out[0] == 0 \u0026\u0026 out[1] == 0 \u0026\u0026 out[2] == 0 \u0026\u0026 (out[3] \u003e\u003e 5) == 0) { printf(\"%s\\n\", buf+10); break; } } return 0; } // gcc -O2 pow.c -lcrypto \u0026\u0026 ./a.out pzlYZX5ZEb \u0026\u0026 rm ./a.out python: from Crypto.Util.number import getPrime,bytes_to_long from pwn import * import urllib.parse as parse from pwnlib.util.iters import bruteforce from hashlib import sha256 def brute_force(prefix,s): return bruteforce(lambda x:sha256((x+prefix).encode()).hexdigest()==s,string.ascii_letters+string.digits,length=4,method='fixed') p=remote('202.112.238.82', 10010) p.recvuntil(b\"sha256(XXXX+\") prefix = p.recvn(16).decode() p.recvuntil(b\") == \") s = p.recvn(64).decode() log.warning(prefix) log.warning(s) p.sendline(brute_force(prefix,s)) p.interactive() ","date":"2023-09-25","objectID":"/misc/:6:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"docker docker rm -f `docker ps -a -q` ","date":"2023-09-25","objectID":"/misc/:7:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"自定义传参规则 void __usercall xxxxx(char* a1@\u003crdi\u003e) ","date":"2023-09-25","objectID":"/misc/:7:1","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"修改ida字符串显示 # puts(aStr) ---\u003e puts(\"str\") change str seg -\u003e r_x ","date":"2023-09-25","objectID":"/misc/:7:2","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"musl-gcc for kernel # we cannot compile the exploit using musl-gcc, which produces small binary. The problem is that it seems that musl-gcc cannot find the \u003clinux/xxx.h\u003e header files. I solved this by preprocessing exploit using gcc -E and compiling the preprocessing output using musl-gcc gcc -E exp.c -o fs/exp.c musl-gcc -static fs/exp.c -o fs/exp ","date":"2023-09-25","objectID":"/misc/:8:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"remote exp upload from pwn import * import base64 context.log_level = \"debug\" with open(\"./exp\", \"rb\") as f: exp = base64.b64encode(f.read()) def do_pow(r): cmd = r.recvline()[:-1] rr = os.popen(cmd.decode()) r.sendline(rr.read()) p = remote('babypf.seccon.games',9009) do_pow(p) try_count = 1 while True: log.info(\"no.\" + str(try_count) + \" time(s)\") p.sendline() p.recvuntil(\"/ $\") count = 0 for i in range(0, len(exp), 0x200): p.sendline(\"echo -n \\\"\" + exp[i:i + 0x200].decode() + \"\\\" \u003e\u003e /tmp/b64_exp\") count += 1 for i in range(count): p.recvuntil(\"/ $\") p.sendline(\"cat /tmp/b64_exp | base64 -d \u003e /tmp/exploit\") p.sendline(\"chmod +x /tmp/exploit\") randomization = (try_count % 1024) * 0x100000 log.info('trying randomization: ' + hex(randomization)) if not p.recvuntil(b\"Rebooting in 1 seconds..\", timeout=20): break log.warn('failed!') try_count += 1 log.success('success to get the root shell!') p.interactive() ","date":"2023-09-25","objectID":"/misc/:9:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"debug # debug.sh gdb qemu-system-x86_64 --pid `ps -ef | grep qemu | awk '{print $2}' | head -n 1` -x ./debug.source # debug.source b *addr c ","date":"2023-09-25","objectID":"/misc/:10:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"tmux set-option -g mouse on # 开启鼠标支持 setw -g mode-keys vi # 支持vi模式 set-option -s set-clipboard on # 开启系统剪切板支持 ## 鼠标滚轮模拟 # Emulate scrolling by sending up and down keys if these commands are running in the pane tmux_commands_with_legacy_scroll=\"nano less more man\" bind-key -T root WheelUpPane \\ if-shell -Ft= '#{?mouse_any_flag,1,#{pane_in_mode}}' \\ 'send -Mt=' \\ 'if-shell -t= \"#{?alternate_on,true,false} || echo \\\"#{tmux_commands_with_legacy_scroll}\\\" | grep -q \\\"#{pane_current_command}\\\"\" \\ \"send -t= Up Up Up\" \"copy-mode -et=\"' bind-key -T root WheelDownPane \\ if-shell -Ft = '#{?pane_in_mode,1,#{mouse_any_flag}}' \\ 'send -Mt=' \\ 'if-shell -t= \"#{?alternate_on,true,false} || echo \\\"#{tmux_commands_with_legacy_scroll}\\\" | grep -q \\\"#{pane_current_command}\\\"\" \\ \"send -t= Down Down Down\" \"send -Mt=\"' ","date":"2023-09-25","objectID":"/misc/:11:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["misc"],"content":"patchelf patchelf --set-interpreter ld_path xxx patchelf --set-rpath libc_dir xxx ","date":"2023-09-25","objectID":"/misc/:12:0","tags":["misc"],"title":"Misc","uri":"/misc/"},{"categories":["pwn"],"content":"idapython 从-1开始学习ida。 全部抄自《IDAPython 初学者指南》，手动翻译成了ida7.5+python3。 ","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:0:0","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"指令学习 ","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:0","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"节区操作 ea = idc.get_screen_ea() ea = here() # 函数获取当前地址 ida_ida.inf_get_min_ea() ida_ida.inf_get_max_ea() # 获取当前文件的最大、小地址 idc.get_segm_name(ea) # get text idc.GetDisasm(ea) # get disassembly idc.print_insn_mnem(ea) # get mnemonic idc.print_operand(ea, 0) # get first operand idc.print_operand(ea, 1) # get second operand 一个例子 add rsp, 8 idc.print_insn_mnem(ea) --\u003e add idc.print_operand(ea, 0) --\u003e rsp idc.print_operand(ea, 1) --\u003e 8 有些时候我们必须确认一个地址是否在当前的程序中存在，那么我们可以使用idaapi.BADADDR 或者 BADADDR 来确认该地址。 idaapi.BADADDR if BADADDR != here(): print(\"valid address\") # 从遍历所有段 import idautils for seg in idautils.Segments(): print(idc.get_segm_name(seg),idc.get_segm_start(seg),idc.get_segm_end(seg)) idc.get_next_seg(ea) # 获取当前地址所在段的下一个段的起始地址 selector_by_name(\".text\") # 返回bas的值，也就是区段的序号 get_segm_by_sel(selector_by_name(\".text\")) # 组合技获得text段起始地址 ","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:1","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"函数 # 何遍历所有的段中的所有函数 for func in idautils.Functions(): print(hex(func), idc.get_func_name(func)) idc.get_func_name(func) # 通过某个地址获取函数的名称 func = idaapi.get_func(ea) type(func) # \u003cclass 'idaapi.func_t'\u003e print(\"Start: 0x%x, End: 0x%x\" % (func.start_ea, func.end_ea)) # Start: 0xe79, End: 0x1078 dir(func) # 来获取这个类究竟有哪些属性可以使用 idc.get_next_func(ea) idc.get_prev_func(ea) # 获取当前函数的前一个或者后一个函数 ","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:2","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"数据 # 获取数据 # 获取当前函数的反汇编 start = idc.get_func_attr(ea, FUNCATTR_START) end = idc.get_func_attr(ea, FUNCATTR_END) # 获取某个函数的首尾地址 cur_addr = start while cur_addr \u003c= end: print(hex(cur_addr), idc.GetDisasm(cur_addr)) cur_addr = idc.next_head(cur_addr, end) 这种方法的一个缺陷是它依赖于指令被包含在函数开始和结束的边界内。打个比方说，函数内有个 jmp 指令，它跳转到比这个函数结束地址还要高的地址中去，意思是这个函数的所有指令可能并不是线性的，它可能会通过jmp 跳出函数边界(起始地址和结束地址)，但其实这段指令仍是属于这个函数的，那么我们使用上述的方法就不能够遍历到该函数要执行的所有指令。这种跳转在代码混淆中非常的常见，所以说我们最好还是使用 idautils.FuncItems(ea) 来循环函数内的指令。 信息收集函数idc.get_func_attr(func, FUNCATTR_FLAGS)可以用来检索关于函数的信息，例如它是否是库中代码，或者函数是否有返回值等。对于一个函数来说有九个可能的标志。 for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) if flags \u0026 FUNC_NORET: print(hex(func), get_func_name(func), \"FUNC_NORET\") if flags \u0026 FUNC_FAR: print(hex(func), get_func_name(func),\"FUNC_FAR\") if flags \u0026 FUNC_LIB: print(hex(func), get_func_name(func),\"FUNC_LIB\") if flags \u0026 FUNC_STATIC: print(hex(func), get_func_name(func),\"FUNC_STATIC\") if flags \u0026 FUNC_FRAME: print(hex(func), get_func_name(func),\"FUNC_FRAME\") if flags \u0026 FUNC_USERFAR: print(hex(func), get_func_name(func),\"FUNC_USERFAR\") if flags \u0026 FUNC_HIDDEN: print(hex(func), get_func_name(func),\"FUNC_HIDDEN\") if flags \u0026 FUNC_THUNK: print(hex(func), get_func_name(func),\"FUNC_THUNK\") if flags \u0026 FUNC_LIB: print(hex(func), get_func_name(func),\"FUNC_BOTTOMBP\") 我们利用了 idautils.Fucntions() 来获取所有已知的函数首地址，然后利用idc.get_func_attr(func, FUNCATTR_FLAGS)获取标志。 ","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:3","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"Flags FUNC_NORET：这个标志表示某个函数是否有返回值，它本身的值是 1，下面是一个没有返回值的函数，注意它没有函数的最后并不是 ret 或者 leave 指令。 FUNC_FAR：这个标志非常少的出现，标志程序是否使用分段内存，它的值为 2。 FUNC_USERFAR：少见+1 FUNC_LIB：这个表示用于寻找库函数的代码。识别库函数代码是非常有必要的，因为我们在分析的时候一般将其跳过，它的值是 4。 一个FUNC_LIB的Demo: for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) # print(get_func_name(func), hex(flags)) if flags \u0026 FUNC_LIB: print(hex(func), \"FUNC_LIB\", get_func_name(func)) FUNC_STATIC：静态函数 FUNC_FRAME：这个标志表示函数是否使用了 ebp 寄存器(帧指针)，使用 ebp 寄存器的函数通常有如下的语法设定，目的是为了保存栈帧。 FUNC_BOTTOMBP：和 FUNC_FRAME 一样，该标志用于跟踪帧指针(ebp)。它作用是识别函数中帧指针是 否等于堆栈指针(esp)。 FUNC_HIDDEN：带有 FUNC_HIDDEN 标志的函数意味着它们是隐藏的，这个函数需要展开才能查看。如 果我们跳转到一个标记为 HIDDEN 的地址的话，它会自动的展开。 FUNC_THUNK：表示这个函数是否是一个 thunk 函数，thunk 函数表示的是一个简单的跳转函数。 ","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:4","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"指令 获取该函数中所有指令地址的集合 dism_addr = list(idautils.FuncItems(here())) for line in dism_addr: print(hex(line), idc.GetDisasm(line)) 函数idautils.FuncItems(ea)实际上返回的是一个迭代器，但是我们将它强制转换为 list 类型。这个 list 以一种连续的方式存储着所有指令的起始地址。现在我们已经完全掌握了如何循环遍历程序中的段，函数和指令，那我们就开始 show 一个非常有用的例子。有时候我们会逆向一个加壳的代码，这时知道代码中哪里进行了动态调用对分析是非常有帮助的。一个动态的调用可能是由 call 或者 jump 加上一个操作数来实现的，比如说 call eax，或者 jmp edi。 for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) if flags \u0026 FUNC_LIB or flags \u0026 FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for line in dism_addr: m = idc.print_insn_mnem(line) if m == 'call' or m == 'jmp': op = idc.get_operand_type(line, 0) if op == o_reg: print(\"0x%x %s\" % (line, idc.GetDisasm(line))) 我们使用 idautils.Functions()获取所有的函数，然后利用 idc.get_func_attr(ea, FUNCATTR_FLAGS)获取每个函数的标志，如果这个函数是库函数或者这个函数是 thunk 函数，那我们就跳过对它的处理，接下来我们使用 idautils.FuncItems(ea) 获取函数中每个指定的起始地址。然后使用idc.print_insn_mnem(ea)来获取每条指令的操作符，判断操作符是否为 call 或者 jmp。如果是的话，我们就使用 idc.get_operand_type(ea, n)来获取操作数，这个函数返回的一个 opt.type 类型的数值(int 类型)，这个数值可表示的类型为寄存器，内存引用等等。我们检查每条 call 或者 jmp指令的操作数，如果是寄存器的话就打印出该行指令。 通过强制转换为list我们获取了所有函数的地址，这样我们可以使用idc.next_head和idc.prev_head来获取附近指令的地址。注意，与之类似的ida_bytes.next_addr是获取附近的地址。 ea = here() print(hex(ea), idc.GetDisasm(ea)) next_instr = idc.next_head(ea) print(hex(next_instr), idc.GetDisasm(next_instr)) ","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:5","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"操作数 我们可以使用 idc.get_operand_type(ea,n)来获取操作数类型，ea 是一个地址，n 是一个索引。操作数总共有八种不同的类型。 o_void：如果指令没有任何操作数，它将返回 0。例如retn o_reg：如果操作数是寄存器，则返回这种类型，它的值为 1 o_mem：如果操作数是直接寻址的内存，那么返回这种类型，它的值是 2，这种类型对寻找 DATA的引用非常有帮助。例如 cmp ds:dword_A152B8, 0 o_phrase：如果操作数是利用基址寄存器和变址寄存器的寻址操作的话，那么返回该类型，值为 3。例如mov [edi+ecx], eax o_displ：如果操作数是利用寄存器和位移的寻址操作的话，返回该类型，值为 4。如mov eax, [edi+18h] o_imm；如果操作数是一个确定的数值的话，那么返回类型，值为 5，如 add esp, 0Ch o_far：这种返回类型在 x86 和 x86_64 的逆向中不常见。它用来判断直接访问远端地址的操作数，值为 6 o_near：这种返回类型在 x86 和 x86_64 的逆向中不常见。它用来判断直接访问近端地址的操作数，值为 7 例子1 这个例子的目的是创建一个 python 的字典，字典包含了可执行文件中使用的所有偏移量，让偏移量作为字典的 key，而每个 key 对应的 value 存储着所有使用该偏移量的地址。 import idautils import idaapi displace = {} # for each known function for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 FUNC_LIB or flags \u0026 FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for curr_addr in dism_addr: op = None index = None insn = ida_ua.insn_t() # same as idc.GetOptype, just a different way of accessing the types idaapi.decode_insn(insn, curr_addr) if insn.Op1.type == idaapi.o_displ: op = 1 if insn.Op2.type == idaapi.o_displ: op = 2 if op == None: continue if \"bp\" in idc.print_operand(curr_addr,0) or idc.print_operand(curr_addr, 1): # ebp will return a negative number if op == 1: index = (~(int(insn.Op1.addr) - 1) \u00260xFFFFFFFF) else: index = (~(int(insn.Op2.addr) - 1) \u00260xFFFFFFFF) else: if op == 1: index = int(insn.Op1.addr) else: index = int(insn.Op2.addr) # create key for each unique displacement value if index: if index not in displace: displace[index] = [] displace[index].append(curr_addr) 代码的最开始大家应该很熟悉了，我们利用了idautils.Functions()和idc.get_func_attr(func, FUNCATTR_FLAGS)来获取所有的函数，然后剔除掉其中库函数和trunk函数，随后我们又利用idautils.FuncItems(ea)来获取每个函数的指令。到这里我们使用了一个新函数idaapi.decode_insn(insn, ea)，这个函数需要传入我们想要解读的每个指令的开始地址。一旦这个指令成功的被解读，我们就可以通过insn来获取该指令的不同属性和参数。 Python\u003edir(insn) ['Op1', 'Op2', 'Op3', 'Op4', 'Op5', 'Op6', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get_auxpref__', '__get_operand__', '__get_ops__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__set_auxpref__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__swig_destroy__', '__weakref__', 'add_cref', 'add_dref', 'add_off_drefs', 'assign', 'auxpref', 'create_op_data', 'create_stkvar', 'cs', 'ea', 'flags', 'get_canon_feature', 'get_canon_mnem', 'get_next_byte', 'get_next_dword', 'get_next_qword', 'get_next_word', 'insnpref', 'ip', 'is_64bit', 'is_canon_insn', 'is_macro', 'itype', 'ops', 'segpref', 'size', 'this', 'thisown'] 我们使用了 insn.Op1.type 来获取操作数的类型，需要注意的是这里操作数的起始索引并不是 idc.get_operand_type(ea,n)中的 0，而是 1。然后我们用idc.print_operand(ea, n)检查两个操作数中哪个的类型是 o_displ。 我们已经获取了操作符的字符串表示，那么我们检查操作符中是否包含了“bp”字符串，这是一个快速判断操作符的中寄存器是否为 bp，ebp 或 者 rbp 的方法。检查”bp”字符串的目的在于确定偏移量是否是一个负数。我们使用insn.Op1.addr 来获取偏移量，这个方法会返回一个字符串。然后我们把他转换成为一个 integer 类型，如果需要的话把它转换为正数，然后我们把它放进脚本最开始定义的字典 display 中去。这样就完成了我们的操作，之后如果你想要查找使用某个偏移量的所有地址，请使用如下所示的代码即可： for x in displace[0x130]: print(hex(x), GetDisasm(x)) 例子2 有时候我们在逆向分析一个可执行文件的内存转储的时候，有些操作数就不是一个偏移量了。看如下代码： seg000:00BC1388 push 0Ch seg000:00BC138A push 0BC10B8h seg000:00BC138F push [esp+10h+arg_0] seg000:00BC1393 call ds:_strnicmp 第二个被 push 的值是一个存在内存中的偏移。如果我们通过右键把这个偏移定义为data 类型，我们可以看到这个偏移其实是一个字符串(就是程序里静态的字符串)，当然完成这个定义操作很简单，但是，你懂的，有时候这种操作太多了话就需要写一个脚本来自动完成这件事情的说。 min = ida_ida.inf_get_min_ea() max = ida_ida.inf_get_max_ea() # for each known function for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 FUNC_LIB or flags \u0026 FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for curr_addr in dism_addr: if idc.get_operand_type(curr_addr, 0) == 5 and (min \u003c idc.get_operand_value(curr_addr,0) \u003c max): idc.op_plain_offset(curr_addr, 0, 0) if idc.get_operand_type(cu","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:6","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"交叉引用(Xrefs) 能够定位 data 段和 code 段的交叉引用是非常重要的，交叉引用的重要性在于它能够提供某个确定的数据或者某个函数被调用的位置。举个栗子，如果我们想要知道哪些地址调用了 WriteFile()函数，我们所要做的就是在导入表中找到 WriteFile()函数，然后查看其交叉引用即可。 wf_addr = idc.get_name_ea_simple(\"_puts\") print(hex(wf_addr), idc.GetDisasm(wf_addr)) # 0x202150 extrn puts:near for addr in idautils.CodeRefsTo(wf_addr, 0): print(hex(addr), idc.GetDisasm(addr)) # 打印出该 API 的所有交叉引用 我们可以通过调用 idautils.Names()函数来获取在 IDA 中任何 API 和被重命名的函数的相关信息，该函数将返回一个类型为(ea, str_name)的元组。 函数idautils.DataRefsTo(ea)只有一个地址参数，它返回该数据地址的所有交叉引用(迭代器)。 重点来了！！！ 这里我们使用前面所提到的有一种更加通用的方法来获取交叉引用，该方法调用两个函数就能完成获取所有交叉引用地址和调用地址的效果，这两个函数就是 idautils.XrefsTo(ea, flags=0)和 idautils.XrefsFrom(ea, flags=0) for xref in idautils.XrefsTo(ea, 1): print(xref.type, idautils.XrefTypeName(xref.type), hex(xref.frm), hex(xref.to), xref.iscode) 对于刚刚的extern，我们可以这样 print(hex(xref.frm), idc.GetDisasm(xref.frm)) # 0x201f80 dq offset puts 获得的其实是puts的got表地址。跳转到got表再次使用上面的代码，我们得到了puts的plt表，再使用就获得了所有的call puts了。这可以给我们提供一个思路去检索我们想要的危险函数调用。 回到正题，第一行显示了一个字符串的的地址，我们使用idautils.XrefsTo(ea,1)来获取该字符串的所有交叉引用。我们使用xref.type来指明该交叉引用的类型，idautils.XrefTypeName(xref.type)用来打印表示该类型的含义，这其中有十二种不同的类型。 0 = 'Data_Unknown' 1 = 'Data_Offset' 2 = 'Data_Write' 3 = 'Data_Read' 4 = 'Data_Text' 5 = 'Data_Informational' 16 = 'Code_Far_Call' 17 = 'Code_Near_Call' 18 = 'Code_Far_Jump' 19 = 'Code_Near_Jump' 20 = 'Code_User' 21 = 'Ordinary_Flow' xref.frm 打印出该地址的交叉引用，xref.to 打印出改地址本身，xref.iscode 打印出该交叉引用是否在代码段中，上述的代码我们使用了 idautils.XrefsTo(ea, 1)并将其 flag 位设为了1，如果我们将 flag 设为 0 的话，那么它将会显示该地址的任意交叉引用，举个栗子： .text:1000AAF6 jnb short loc_1000AB02 ; XREF .text:1000AAF8 mov eax, [ebx+0Ch] .text:1000AAFB mov ecx, [esi] .text:1000AAFD sub eax, edi .text:1000AAFF mov [edi+ecx], eax .text:1000AB02 .text:1000AB02 loc_1000AB02: ; ea is here() .text:1000AB02 mov byte ptr [ebx], 很显然AAF6引用了ea，但是如果flag为0的话结果还会有AAFF也就是程序正常执行流。 这种方法对于我们自己命名的也有用。 idc.set_name(ea, \"RtlCompareMemory\", SN_CHECK) for xref in idautils.XrefsTo(ea, 1): print(xref.type, idautils.XrefTypeName(xref.type), hex(xref.frm), hex(xref.to), xref.iscode) 当然打印所有的交叉引用可能会感觉有点儿重复的说。 Python\u003eprint hex(ea), idc.GetDisasm(ea) 0xa21138 extrn GetProcessHeap:dword Python\u003efor xref in idautils.XrefsTo(ea, 1): print xref.type, idautils.XrefTypeName(xref.type), hex(xref.frm), hex(xref.to), xref.iscode Python\u003e 17 Code_Near_Call 0xa143b0 0xa21138 1 17 Code_Near_Call 0xa1bb1b 0xa21138 1 3 Data_Read 0xa143b0 0xa21138 0 3 Data_Read 0xa1bb1b 0xa21138 0 Python\u003eprint(idc.GetDisasm(0xa143b0)) call ds:GetProcessHeap 重复性来自于 Data_Read 和 Code_Near 类型的交叉引用都被识别出来，所以下面利用set 的方法可以 精简一下这些地址： def get_to_xrefs(ea): xref_set = set([]) for xref in idautils.XrefsTo(ea, 1): xref_set.add(xref.frm) return xref_set def get_frm_xrefs(ea): xref_set = set([]) for xref in idautils.XrefsFrom(ea, 1): xref_set.add(xref.to) return xref_set 精简后的例子： Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0xa21138 extrn GetProcessHeap:dword Python\u003eget_to_xrefs(ea) set([10568624, 10599195]) Python\u003e[hex(x) for x in get_to_xrefs(ea)] ['0xa143b0', '0xa1bb1b'] ","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:7","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"搜索 我们其实已经能够通过遍历所有已知的函数及其指令来达到一种基本的搜索效果，这当然很有用，但是有时候我们需要搜索一些特定的字节，比如说 0x55,0x8b,0xec 这种字节序列，这 3 个字节其实代表的汇编代码为 push ebp, mov ebp, esp 。所以我们可以使用idc.FindBinary(ea,flag, searchstr, radix=16)来实行字节或者二进制的搜索。ea 代表啥就不说了，flag 代表搜索方向或者条件。 SEARCH_UP = 0 SEARCH_DOWN = 1 SEARCH_NEXT = 2 SEARCH_CASE = 4 SEARCH_REGEX = 8 SEARCH_NOBRK = 16 SEARCH_NOSHOW = 32 SEARCH_UNICODE = 64 SEARCH_IDENT = 128 SEARCH_BRK = 256 上面的类型不必要都看一遍，但是还是要看看一些常用的类型： SEARCH_UP 和 SEARCH_DOWN 用来指明搜索的方向 SEARCH_NEXT 用来获取下一个已经找到的对象 SEARCH_CASE 用来指明是否区分大小写 SEARCH_NOSHOW 用来指明是否显示搜索的进度 SEARCH_UNICODE 用于将所有搜索字符串视为 Unicode pattern = '55 48 89 E5' addr = ida_ida.inf_get_min_ea() for x in range(0,5): addr = idc.find_binary(addr, SEARCH_DOWN|SEARCH_NEXT, pattern) if addr != idc.BADADDR: print(hex(addr), idc.GetDisasm(addr)) 结果： Python\u003e 0x911 push rbp 0x940 push rbp 0x94a push rbp 0x9ea push rbp 0xa84 push rbp 第一行我们定义了要搜索的形式，搜索形式可以是 16 进制格式，比如 0x55 0x8B 0xEC和 55 8B EC 都是可以的，\\x55\\x8B\\xEC 这种格式可不行，除非你使用 idc.find_text(ea, flag, y, x, searchstr)这个函数。ida_ida.inf_get_min_ea()用来获取可执行文件的最开始的地址，接下来我们将idc.find_binary(ea, flag,searchstr, radix=16)的返回结果设置为 addr 变量。在搜索时最重要的是验证结果是否符合预期，首先我们将地址与 idc.BADADDR 进行比较，然后打印出该地址和该地址的反汇编结果。 搜索字节序列是很有用的，但是有时候我们想要查找类似于“chrome.dll”这样的字符串。我们可以利用 hex(y)函数来将“chrome.dll”字符串转换成为 16 进制的字节序列，但是，太蠢了，如果字符串是 unicode 格式呢，你还得重新考虑了，好了，不瞒各位，最好的方法是find_text(ea,flag, y, x, searchstr) 。这个函数看起来是不是很熟悉，因为它很像函数idc.find_binary 的说，参数里面，ea 是地址，flag 是搜索方向和搜索类型。y 是从 ea 开始搜索的行数，x 是行中的坐标。这两个参数通常置 0，现在我们开始查找字符串“Accept”的出现的次数。当然你可以换换其他的字符串，可以从字符串窗口(shift+F12)获得。 cur_addr = ida_ida.inf_get_min_ea() end = ida_ida.inf_get_max_ea() while cur_addr \u003c end: cur_addr = idc.find_text(cur_addr, SEARCH_DOWN, 0, 0, \"Exit\") if cur_addr == idc.BADADDR: break else: print(hex(cur_addr), idc.GetDisasm(cur_addr)) cur_addr = idc.next_head(cur_addr) 结果： Python\u003e 0x408 Elf64_Sym \u003coffset aExit - offset byte_468, 12h, 0, 0, offset dword_0, \\; \"exit\" 0x473 db 'exit',0 0x760 Elf64_Rela \u003c201FB8h, 0E00000007h, 0\u003e; R_X86_64_JUMP_SLOT exit 0x820 jmp cs:exit_ptr 0xa49 call _exit 0xafd lea rdi, a3Exit; \"3.Exit\" 0xb75 call _exit 0xbaf call _exit 0xc99 call _exit 0xcf2 push rbp 0xd1e leave 0xd1f retn 我们利用 ida_ida.inf_get_min_ea()来获取可执行文件的最小地址， 将其赋给 cur_addr。利用 ida_ida.inf_get_max_ea()赋值给 end。因为不知道该字符串出现的次数，所以我们从上往下搜索直到最大地址。我们把idc.find_text 的返回值赋给 cur_addr。因为我们利用了 idc.next_head(ea)使当前地址不断增长，所以就不需要在 idc.find_text()中添加 SEARCH_NEXT 的标志。为什么我们要手动的增加地址呢，因为一行字符串中可能出现多次要查找的字符串，往上翻认真阅读 SEARCH_NEXT的标志的意思，你就发现不手动的话会陷入一个死循环(但是测试的时候，算了你们自己测吧，估计我测的有问题)。 除了以上述描述的搜索方式以为，还有一系列的函数用来查找其他类型。通过这写 API的名称就能容易的识别出它们的功能，在讨论查找其他类型之前我们首先来看一下如何通过地址来识别他们的类型，IDAPython 中有如下的一些函数用来判断一个地址的类型，这些APIs 返回的是 bool 值 True 或者 False。 ida_bytes.is_code(f)：判断 IDA 是否将其判定为代码 ida_bytes.is_data(f)：判断 IDA 是否将其判定为数据 ida_bytes.is_tail(f)：判断 IDA 是否将其判定为尾部 ida_bytes.is_unknown(f)：判断 IDA 是否将其判定为未知，即既不是数据，也不是代码 ida_bytes.is_head(f)：判断 IDA 是否将其判定为头部 f 这个参数是新出现的，相比起于传递地址，我们还要先通过 ida_bytes.get_full_flags(ea)获取地址的内 部标志表示，然后再传给 idc.is 系列函数当参数，代码如下： idc.is_code(ida_bytes.get_full_flags(ea)) ida_search.find_code(ea, flag)：该函数用来寻找被标志为代码的下一个地址 这对我们想要查找数据块的末尾是很有帮助的。如果 ea 是代码地址，那么该函数返回下一个代码地址，flag 参数看前面的 idc.find_text就可以了。例子： Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0x4140e8 dd offset dword_4140EC Python\u003eaddr = ida_wearch.find_code(ea, SEARCH_DOWN|SEARCH_NEXT) Python\u003eprint(hex(addr), idc.GetDisasm(addr)) 0x41410c push ebx 可以看到0x4140e8是某个数据的地址。我们将idc.find_code(ea,SEARCH_DOWN|SEARCH_NEXT)的返回值赋给addr，然后打印出该地址和它的反汇编代码。通过该函数我们直接跳过了36个字节获取到了代码段的首地址。 ida_search.find_data：该函数和上一个函数 FindCode()差不多，除了它返回的是数据段的地址 我们反转一下上一个场景，然后通过代码段地址去寻找数据段首地址，代码如下 Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0x41410c push ebx Python\u003eaddr = ida_search.find_data(ea, SEARCH_UP|SEARCH_NEXT) Python\u003eprint(hex(addr), idc.GetDisasm(addr)) 0x4140ec dd 49540E0Eh, 746E6564h, 4570614Dh, 7972746Eh, 8, 1,4010BCh ida_search.find_unknown(ea, flag):该功能用于查找 IDA 未识别为代码或数据的字节地址 未知类型需要通过观察或脚本进一步手动分析。 Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0x406a05 jge short loc_406A3A Python\u003eaddr = ida_search.find_unknown(ea, SEARCH_DOWN) Python\u003eprint(hex(ad","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:8","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"数据选取 有时候我们并不是只想写自动查找数据和代码的脚本，也许你已经知道了代码或者数据的地址，你现在想选取它们分析一下。可能我们只是想要把突出某些代码然后在这些代码上面利用 IDAPython 进行工作。为了获得选定数据的边界，我们可以使用 idc.read_selection_start()来获取开始地址和 idc.read_selection_end()来获得结束地址，不举例了。 注意在分析 64 位可执行文件的时候容易出错，因为 64 位地址容易导致整数 integer 的溢出。 ","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:9","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"注释和重命名 我们使用 idc.set_cmt(ea, comment, 0)来增加注释，idc.set_cmt(ea, comment, 1)来增加重复性注释，ea 是要添加注释的地址。下面代码在一条指令(用 XOR 清零寄存器)出现的时候自动增加注释。 for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 FUNC_LIB or flags \u0026 FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for ea in dism_addr: if idc.print_insn_mnem(ea) == \"xor\": if idc.print_operand(ea, 0) == idc.print_operand(ea, 1): print(hex(ea), idc.GetDisasm(ea)) comment = \"%s = 0\" % (idc.print_operand(ea,0)) idc.set_cmt(ea, comment, 0) 如前所述，我们通过调用 idautils.Functions()来循环遍历所有函数，并通过调用 list(idautils. FuncItems(func))遍历所有指令。然后利用 idc.print_insn_mnem(ea)获取操作符，并判断是否为 XOR。然后利用 idc.print_operand(ea, n)判断两个操作数是否相等，如果是的话，那么给它加上常规注释。 .text:000000D90 xor ebp, ebp ; ebp = 0 如果要增加重复性注释，那么我们使用 idc.set_cmt(ea, comment, 1) 。 这样做好像更有用一点，因为我们可以看到一些分支做了清零，就像是返回 0 的操作。要获取一个注释我们可以使用 ida_bytes.get_cmt(ea, repeatable)该函数，ea 是地址，repeatable 是 bool 值。要获取上述的注释，我们可以使用如下的代码： ida_bytes.get_cmt(ea, False) 如果要获取重复性注释使用 ida_bytes.get_cmt(ea, True)就可以了。当然不只是指令可以做注释，函数也可以做注释的说，我们利用 idc.set_func_cmt(ea, cmt, repeatable)注释函数和利用 idc.get_func_cmt(ea, repeatable)获取函数的注释。ea 可以是函数中的任何地址，cmt 是我们要添加的注释，repeatable 同上面一样。将函数的注释标记为可重复性的话，那么它会在任何调用该函数的地方增加注释。 Python\u003eidc.get_func_name(ea) done Python\u003eidc.set_func_cmt(ea, \"done\", 1) True 第一行我们打印函数的名字，然后我们利用idc.set_func_cmt(ea, comment, repeatable)来设置一个可重复性注释（check out later）给该函数。如果我们去观察函数的起始地址就可以发现我们增加的注释。因为函数的注释是可重复性的，所以函数的交叉引用地方我们同样能看到注释。这样的话就能够很好的提示我们函数的功能。 重命名函数和地址是一项非常常见的自动化任务，特别是在一些于地址无关代码（PIC），加壳或者封装函数中，因为在 PIC 代码和脱壳代码中，导入表可能并不存在于转储中。而封装函数的功能只是简单的调用 API 而已。 idc.set_name(ea, \"func_name\", SN_CHECK) 要重命名一个操作数，我们需要拿到它的地址先，比如在 004047B0 有一个双字我们想要重命名： .text:004047AD lea ecx, [ecx+0] .text:004047B0 mov eax, dword_41400C .text:004047B6 mov ecx, [edi+4BCh] 要获取操作数的数值我们可以使用 get_operand_value(ea, n) Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0x4047b0 mov eax, dword_41400C Python\u003eop = idc.get_operand_value(ea,1) Python\u003eprint(hex(op), idc.GetDisasm(op)) 0x41400c dd 2 Python\u003eidc.set_name(op, \"BETA\", SN_CHECK) True Python\u003eprint(hex(ea), idc.GetDisasm(ea)) 0x4047b0 mov eax, BETA[esi] 第一行我们打印了当前地址信息，然后我们把第二个操作数dword_41400C赋值给op，然后使用 idc.set_name(op, \"name, SN_CHECK)进行重命名，最后打印出新的被重命名的名字。 好了，既然我们现在基础已经很好了，我们现在就用我们所学的来自动化命名封装函数。请注意注释的意思来保证你能够理解代码逻辑。 import idautils def rename_wrapper(name, func_addr): if idc.set_name(func_addr, name, SN_NOWARN): print(\"Function at 0x%x renamed %s\" %( func_addr,idc.get_func_name(func))) else: print(\"Rename at 0x%x failed. Function %s is being used.\"% (func_addr, name)) return def check_for_wrapper(func): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) # skip library \u0026 thunk functions if flags \u0026 FUNC_LIB or flags \u0026 FUNC_THUNK: return dism_addr = list(idautils.FuncItems(func)) # get length of the function func_length = len(dism_addr) # if over 32 lines of instruction return if func_length \u003e 64: print(\"over 64 lines of instruction return, func_len is 0x%x.\" % func_length) return func_call = 0 instr_cmp = 0 op = None op_addr = None op_type = None # for each instruction in the function for ea in dism_addr: m = idc.print_insn_mnem(ea) if m == 'call' or m == 'jmp': if m == 'jmp': temp = idc.get_operand_value(ea,0) # ignore jump conditions within the function boundaries if temp in dism_addr: print(\"jump conditions within the function boundaries\") continue func_call += 1 # wrappers should not contain multiple function calls if func_call == 2: print(\"wrappers contain multiple function calls\") return op_addr = idc.get_operand_value(ea , 0) op_type = idc.get_operand_type(ea,0) elif m == 'cmp' or m == 'test': # wrappers functions should not contain much logic. instr_cmp += 1 if instr_cmp == 3: print(\"wrappers functions contain so much logic\") return else: continue # all instructions in the function have been analyzed if op_addr == None: return name = idc.get_name(op_addr, ida_name.GN_VISIBLE) # skip mangled function names if \"[\" in name or \"$\" in name or \"?\" in name or \"@\" in name or name == \"\": print(\"m","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:10","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"访问原始数据 在逆向工程中获取原始数据是非常重要的。原始数据是 16 进制的字节，它们被解释为数据或者代码，ida 中我们可以在反汇编代码窗口的左侧看到这些原始数据。 要获取原始数据的话我们首先要指定获取的单元大小，这些获取原始数据 API 的命名规则就是以单元大小。我们使用 idc.get_wide_byte(ea)获取单字节，idc.get_wide_word(ea)获取字等等。 ","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:11","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"},{"categories":["pwn"],"content":"补丁 有时候我们在逆向一个恶意软件的时候，样本会有被加密的字符串。这会阻碍我们分析的过程和组织我们通过字符串来定位关键点。这种情况下给 idb 文件打补丁就很有用了。重命名地址但是好像并没有卵用，因为命名是有约束限制的，所以我们需要给某些地址做patch了，我们可以使用如下的函数来 patch： ida_bytes.patch_byte(ea, value) ida_bytes.patch_word(ea, value) ida_bytes.patch_dword(ea, value) ida_bytes.patch_qword(ea, value) 逆向的基操，懒得举例了。 剩下三个自己看看吧，写不动了。 ","date":"2021-03-01","objectID":"/idapython%E7%AC%94%E8%AE%B0/:1:12","tags":["pwn","kernel"],"title":"idapython笔记","uri":"/idapython%E7%AC%94%E8%AE%B0/"}]